

 [图解！24张图彻底弄懂九大常见数据结构！](https://mp.weixin.qq.com/s/lnMvB3zgWZTmCfCvnNwTbA)

##超集

 如果一个集合S2中的每一个元素都在集合S1中，且集合S1中可能包含S2中没有的元素，则集合S1就是S2的一个超集，反过来，S2是S1的子集。 S1是S2的超集，若S1中一定有S2中没有的元素，则S1是S2的真超集，反过来S2是S1的真子集。

#算法

##排序算法的稳定性？

排序算法可以根据稳定性分为两种：稳定和非稳定算法。那么怎么区分它们？

如果链表中存在两个相同元素，稳定排序算法可以在排序之后保持他两原来的次序，而非稳定性的则不能保证

##简单排序类别

有两种简单排序算法分别是插入排序和选择排序，两个都是数据量小时效率高。实际中插入排序一般快于选择排序，由于更少的比较和在有差不多有序的集合表现更好的性能。但是选择排序用到更少的写操作，所以当写操作是一个限制因素时它被使用到。




##希尔排序的时间性能优于直接插入排序的原因：

当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。
当n值较小时，n和n2的差别也较小，即直接插入排序的最好时间复杂度O(n)和最坏时间复杂度0(n2)差别不大。
在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但由于已经按di-1作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。



##插入排序与选择排序的区别

插入排序类似于选择排序，不同之处是插入排序是一个元素一个元素地往有序序列中插入，而选择排序则是在无序序列中选择最大(最小)元素放入有序队列末尾。一个主要操作有序队列，一个则是无序队列。这样就导致选择排序每次都要遍历一次无序队列，而插入排序则不需要遍历整个有序队列，只需要遍历到该元素应有的位置即可，这样就使得基本有序的队列的复杂度为O(n).
但同时这会导致插入排序用到更多的写操作，因为内部循环时他对数组进行大量的移位操作，大家知道移位操作对于数组是非常低效率的。而选择排序因为每次添加元素都是添加在末尾，所以不需要移位操作

##为什么梳排序和希尔排序都可以通过分组来提高效率呢？

因为插入排序和冒泡排序有几个相似的点：1.当文件初态基本有序时时间复杂度为O(n). 2.数据量小时效率更好，因为最好情况n和最坏情况n^2相差不大。


##归并

分治法 先"分割"再"合并"

##时间复杂度

###定义

时间复杂度是一个函数，它定性描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。

###计算

* 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得T(n)/f(n)的极限值（当n趋近于无穷大时）为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。

* 分析：随着模块n的增大，算法执行的时间的增长率和 f(n) 的增长率成正比，所以 f(n) 越小，算法的时间复杂度越低，算法的效率越高。

* 在pascal中比较容易理解，容易计算的方法是：看看有几重for循环，只有一重则时间复杂度为O(n)，二重则为O(n^2)，依此类推，如果有二分则为O(logn)，二分例如快速幂、二分查找，如果一个for循环套一个二分，那么时间复杂度则为O(nlogn)。




#堆、栈、堆栈、队列

##堆：

###什么是堆？又该怎么理解呢？

* ①堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：
  ·堆中某个节点的值总是不大于或不小于其父节点的值；
  ·堆总是一棵完全二叉树。
  将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。
* ②堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。
* ③堆是应用程序在运行的时候请求操作系统分配给自己内存，一般是申请/给予的过程。
* ④堆是指程序运行时申请的动态内存，而栈只是指一种使用堆的方法(即先进后出)。
  父节点比子节点大的称为最大堆：
  父节点比子节点小的为最小堆：

##栈：

###什么是栈？又该怎么理解呢？

* ①栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。
* ②栈就是一个桶，后放进去的先拿出来，它下面本来有的东西要等它出来之后才能出来（先进后出）
* ③栈(Stack)是操作系统在建立某个进程时或者线程（在支持多线程的操作系统中是线程）为这个线程建立的存储区域，该区域具有FIFO的特性，在编译的时候可以指定需要的Stack的大小。

###堆栈：什么是堆栈？又该怎么理解呢？

* 注意：其实堆栈本身就是栈，只是换了个抽象的名字。
* 堆栈的特性： 最后一个放入堆栈中的物体总是被最先拿出来， 这个特性通常称为后进先出(LIFO)队列。 堆栈中定义了一些操作。 
* 两个最重要的是PUSH和POP。 PUSH操作在堆栈的顶部加入一 个元素。POP操作相反， 在堆栈顶部移去一个元素， 并将堆栈的大小减一。

###堆、栈区别总结：

####1.堆栈空间分配

 * ①栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
 * ②堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。

####2.堆栈缓存方式

* ①栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。
* ②堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

####3.堆栈数据结构区别

* ①堆（数据结构）：堆可以被看成是一棵树，如：堆排序。
* ②栈（数据结构）：一种先进后出的数据结构。

##队列：什么是队列？又该怎么理解呢？

* ①队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。
* ②队列中没有元素时，称为空队列。
* ③建立顺序队列结构必须为其静态分配或动态申请一片连续的存储空间，并设置两个指针进行管理。一个是队头指针front，它指向队头元素；另一个是队尾指针rear，它指向下一个入队元素的存储位置。
* ④队列采用的FIFO(first in first out)，新元素（等待进入队列的元素）总是被插入到链表的尾部，而读取的时候总是从链表的头部开始读取。每次读取一个元素，释放一个元素。所谓的动态创建，动态释放。因而也不存在溢出等问题。由于链表由结构体间接而成，遍历也方便。（先进先出）

###堆、栈、队列之间的区别是？

* ①堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。
* ②栈就是一个桶，后放进去的先拿出来，它下面本来有的东西要等它出来之后才能出来。（后进先出）
* ③队列只能在队头做删除操作,在队尾做插入操作.而栈只能在栈顶做插入和删除操作。（先进先出）



## 树

###完全二叉树：

叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树

###二叉排序树

二叉排序树（Binary Sort Tree 简称BST），又称[二叉查找树](https://baike.baidu.com/item/二叉查找树/7077965)（Binary Search Tree）二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

* （1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
* （2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；
* （3）左、右子树也分别为二叉排序树；
* （4）没有键值相等的结点。

### 平衡二叉树(Balanced Binary Search Tree) 

平衡二叉树是一棵空树或它的左右两个子树的高度差的绝对值不超过1（每个节点左右子树高度差至多为一），并且左右两个子树都是一棵平衡二叉树。

平衡二叉树的常用实现方法有[红黑树](https://baike.baidu.com/item/红黑树/2413209)、[AVL](https://baike.baidu.com/item/AVL/7543015)、[替罪羊树](https://baike.baidu.com/item/替罪羊树/13859070)、[Treap](https://baike.baidu.com/item/Treap)、[伸展树](https://baike.baidu.com/item/伸展树/7003945)等。

##### 红黑树

* （1）任何一个节点都有颜色，黑色或者红色
* （2）根节点是黑色的
* （3）父子节点之间不能出现两个连续的红节点，但是可以出现连续的黑色节点
* （4）任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等
* （5）空节点被认为是黑色的

### 平衡多路查找树（多叉树、B-树）

（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；

（2）子节点数：非叶节点的子节点数p取值范围：1< p<=M     ,即子节点数 >1，且<=M ，且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；

（3）关键字数：非根点的关键字数量k取值范围：ceil(m/2)-1 <= k <= m-1 。 即关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);

（4）所有叶子节点均在同一层、或者说根节点到每个叶子节点的长度都相同。叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;

B树结构如下

![B树](/Users/yangyibo/GitWork/JavaTest/doc/img/B树.png)



##### `m` 阶B-Tree ：以`分支数`讨论

> - **上限**：`每个节点`最多有 `m` 个分支
> - **下限**：
>   根节点至少`2`个分支，
>   非根节点至少有ceil(m/2)（进1法）个分支
> - 所以也称 `m` 阶B-Tree 为 **`( ⌈m/2⌉ , m )`**树 ，即超级节点（除根节点）的**`分支数的上下限 ！！！！！！ `** [注] 超级节点关键码的个数 = 节点分支数 - 1

例：
m = 4 阶，（2，4）树
m = 5 阶，（3，5）树
m = 6 阶，（3，6）树

![B树2](/Users/yangyibo/GitWork/JavaTest/doc/img/B树2.png)

**B树的查询流程**

二分查找

### B树插入

插入的时候，我们需要记住一个规则：**判断当前结点关键字k的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可。**

插入算法实现是个动态过程，也就意味着在此过程中，若破坏了B-Tree的结构，则需要相应的恢复处理





# 递归

递归，在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法。简单来说，递归表现为函数调用函数本身。例子：查字典。

递归的**「本义」**，就是原问题可以拆为同类且更容易解决的子问题，即**「原问题和子问题都可以用同一个函数关系表示。递推函数的等价关系式，这个步骤就等价于寻找原问题与子问题的关系，如何用一个公式把这个函数表达清楚」**

递归有两个显著的特征,终止条件和自身调用:

- 自身调用：原问题可以分解为子问题，子问题和原问题的求解方法是一致的，即都是调用自身的同一个函数。
- 终止条件：递归必须有一个终止的条件，即不能无限循环地调用本身。

递归的过程，可以理解为出入栈的过程的。

递归的应用场景：

- 阶乘问题
- 二叉树深度
- 汉诺塔问题
- 斐波那契数列
- 快速排序、归并排序（分治算法体现递归）
- 遍历文件，解析xml文件

解决递归问题一般就三步，分别是：

- 第一步，定义函数功能
- 第二步，寻找递归终止条件
- 第二步，递推函数的等价关系式



