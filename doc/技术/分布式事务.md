# 基本概念

计算机系统从**集中式到分布式**的变革伴随着包括**分布式网络**、**分布式事务**、**分布式数据一致性**等在内的一系列问题和挑战，同时也催生了一大批诸如**`ACID`、`CAP`和 `BASE`** 等经典理论的快速发展。

为了解决分布式一致性问题，涌现出了一大批经典的一致性协议和算法，最为著名的就是二阶段提交协议（2PC），三阶段提交协议（3PC）和`Paxos`算法。`Zookeeper`的一致性是通过基于 `Paxos` 算法的 `ZAB` 协议完成的。

**ACID**（`Atomicity`原子性，`Consistency`一致性，`Isolation`隔离性，`Durability`持久性）是事务的特点，具有强一致性，一般用于单机事务，分布式事务若采用这个原则会丧失一定的可用性，属于`CP`系统。

**CAP**（`Consistency`一致性，`Availability`可用性，`Partition tolerance`分区容错性）理论是当前分布式系统公认的理论，亦即一个分布式系统不可能同时满足这三个特性，只能三求其二。对于分布式系统，`P`是基本要求，如果没有`P`就不是分布式系统了，所以一般都是在满足`P`的情况下，在`C`和`A`之间寻求平衡。

**BASE**（`Basically Availabe`基本可用，`Soft state`软状态，`Eventually consistency`最终一致性）理论是对大规模的互联网分布式系统实践的总结，用弱一致性来换取可用性，不同于ACID，属于`AP`系统。

BASE理论由eBay的架构师Dan Pritchett提出，**BASE理论是对CAP理论**的延伸，核心思想是即使无法做到强一致性，应用应该可以采用合适的方式达到最终一致性。BASE是指**基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）**。

- 基本可用：指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。
- 软状态：允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。
- 最终一致性：最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。

# 分布式事务

- 强一致分布式事务方案：其中包括两段式提交协议2PC、三段式提交协议3PC。
- 最终一致分布式事务方案：其中包括事件**通知模式**（本地异步事件服务模式、外部事件服务模式、事务消息模式、**最大努力通知**模式）、事务补偿模式（Saga、TCC）。

名词：

* 事务参与者：例如每个数据库（服务）就是一个事务参与者
*  事务协调者：访问多个数据源的服务程序，例如 shopping-service 就是事务协调者
* 资源管理器（Resource Manager, RM）：通常与事务参与者同义
* 事务管理器（Transaction Manager, TM）：通常与事务协调者同义

在分布式事务模型中，一个 TM 管理多个 RM，即一个服务程序访问多个数据源；TM 是一个全局事务管理器，协调多方本地事务的进度，使其共同提交或回滚，最终达成一种全局的 ACID 特性。

# 强一致性

## 2PC

![image-20201202165217991](/Users/yangyibo/Library/Application Support/typora-user-images/image-20201202165217991.png)

**2PC协议中，如果出现协调者和参与者都挂了的情况，有可能导致数据不一致。**

2PC 就是二阶段提交，分别有**协调者和参与者两个角色**，二阶段分别是**准备阶段**和**提交阶段**。

**准备阶段**就是**协调者**向各**参与者**发送准备命令，**这个阶段参与者除了事务的提交啥都做了**，而提交阶段就是协调者看看各个参与者准备阶段都 o 不 ok，如果有 ok 那么就**向各个参与者发送提交命令，如果有一个不 ok 那么就发送回滚命令**。

2PC 是一种**强一致性**的分布式事务，它是同步阻塞的，即在接收到提交或回滚命令之前，**所有参与者都是互相等待**，特别是执行完准备阶段的时候，此时的资源都是锁定的状态，假如有一个参与者卡了很久，其他参与者都得等它，产生长时间资源锁定状态下的阻塞。

**2PC存在的问题：**

总体而言效率低，并且存在单点故障问题，协调者是就是那个单点，并且在极端条件下存在数据不一致的风险

## 3PC

![image-20201202165225378](/Users/yangyibo/Library/Application Support/typora-user-images/image-20201202165225378.png)

三阶段提交就有`CanCommit`、`PreCommit`、`DoCommit`三个阶段。

1. 事务询问（`canCommit`）

- 协调者向参与者发送一个包含事务内容的询问请求，询问是否可以执行事务并等待，确定执行事物所需的条件已经全部完备。
- 参与者根据自己状态判断并回复yes、no

2.执行事务预提交（`preCommit`）

- 若第一步协调者收到全是yes，就发送preCommit请求，参与者开始执行事物。若第一步有收到no，则发布abort请求
- 参与者若收到preCommit则执行事务操作并记录undo和redo然后发送Ack；若收到abort或者超时则中断事务

3.执行事务提交（`doCommit`）

- 协调者收到所有的Ack则发送doCommit请求，若收到了No或者超时则发送abort请求
- 参与者收到doCommit就执行提交并发送ACk，否则执行回滚并发送Ack
- 协调者收到Ack判断是完成事务还是中断事务

**3PC也不是完美的，同样存在问题：**

在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。

所以，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。

# 最终一致性（消息事务）

BASE理论是对CAP理论（**一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）**）的延伸，核心思想是即使无法做到强一致性，应用应该可以采用合适的方式达到最终一致性。BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。

- 基本可用：指分布式系统在出现故障的时候，允许**损失部分可用性，即保证核心可用**。
- 软状态：**允许系统存在中间状态，而该中间状态不会影响系统整体可用性**。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。
- 最终一致性：最终一致性是指系统中的**所有数据副本经过一定时间后，最终能够达到一致的状态**。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。

![image-20201202165402302](/Users/yangyibo/Library/Application Support/typora-user-images/image-20201202165402302.png)

## 事件通知类型（不依赖下游结果）

**事件通知模式上游服务不依赖于下游服务的运行结果**。所以可以最大程度多次的请求下游接口，但是下游接口需要保证**幂等性**

### 事件最大努力通知

有些场景是允许一定程度地丢消息的。于是就发展出事件最大努力通知模式。最大努力通知型的特点是，**业务服务在提交事务后，进行有限次数（设置最大次数限制）的消息发送**，比如发送三次消息，若三次消息发送都失败，则不予继续发送。所以有可能导致消息的丢失。同时，**主业务方需要提供查询接口给从业务服务，用来恢复丢失消息**。**最大努力通知型对于时效性保证比较差**（既可能会出现较长时间的软状态），所以对于数据一致性的时效性要求比较高的系统无法使用。**这种模式通常使用在不同业务平台服务或者对于第三方业务服务的通知，如银行通知、商户通知等。**

**事件通知模式要注意的点：**

通过上面的描述，我们知道只要是**使用事件通知模式，那么消费端收到的消息就有可能是重复的**。那么就需要消费端保证同一条事件不会重复被消费，简而言之就是**保证事件消费的幂等性**。

如果事件本身是具备幂等性的状态型事件，如订单状态的通知（已下单、已支付、已发货等），则需要判断事件的顺序。一般通过时间戳来判断，既消费过了新的消息后，当接受到老的消息直接丢弃不予消费。如果无法提供全局时间戳，则应考虑使用全局统一的序列号。

对于不具备幂等性的事件，一般是动作行为事件，如扣款100，存款200，则应该**将事件ID及事件结果持久化，在消费事件前查询事件ID**，若已经消费则直接返回执行结果；若是新消息，则执行，并存储执行结果。

### MQ通知

无论是 2PC & 3PC 还是 TCC、事务状态表，这些方案本质上都是**事务协调者协调各个事务参与者的本地事务的进度，使所有本地事务共同提交或回滚，最终达成一种全局的 ACID 特性**。在协调的过程中，协调者需要收集各个本地事务的当前状态，并根据这些状态发出下一阶段的操作指令。

但是这些全局事务方案由于操作繁琐、时间跨度大，或者在**全局事务期间会排他地锁住相关资源**，使得整个分布式系统的全局事务的并发度不会太高。这很难满足电商等高并发场景对事务吞吐量的要求，其中利用消息中间件实现的最终一致性全局事务就是一个经典方案。

#### 过程

**上游服务**

* 业务处理逻辑
* 将发送消息的记录，记录到mysql表

上游服务**通过本地事务保证这两上述两个过程在一个事务中**。然后启动一个服务遍历mysql 消息表，将消息发送给mq，直至消息中间件响应 ACK 成功，确保已经写入mq （例如 kafka 的 acks = -1），这样**可能发生消息的重复发送，不过没关系**，只要保证消息不丢失，不乱序就行。发送成功则删除表记录。

**下游服务**（需要保证幂等性）

* 获取消息，由于消息可能多发，所以判断消息是否已经执行过
* 处理业务逻辑，写入消息判断重复表（一个事务），
* 成功后向MQ 发送ACK发送确认消息

下游服务获取消息，判断本地的消息记录表（表中记录唯一事务id），查看该消息是否已经执行过，执行过则直接返回ACK。未执行则进行业务处理，处理成功后写入消息记录表，然后发送ACK确认消息(例如Kafka的 at least once 语义)。

## 事务补偿方案（依赖下游结果）

除了事件通知模式外，事务补偿模式也可以实现事务的最终一致性。

补偿模式比起事件通知模式最大的不同是，**补偿模式的上游服务依赖于下游服务的运行结果，而事件通知模式上游服务不依赖于下游服务的运行结果**。

### Saga模式（有补偿记录）

Saga是一种**纯业务补偿模式**，其设计理念为，业务在调用的时候正常提交，**当一个服务失败的时候，所有其依赖的上游服务都进行业务补偿操作。**

业务补偿模式**要求每个服务都提供补偿接口**，且这种补偿一般来说是**不完全补偿，既即使进行了补偿操作，那条取消的火车票记录还是一直存在数据库中可以被追踪**（一般是有相信的状态字段“已取消”作为标记）**，毕竟已经提交的线上数据一般是不能进行物理删除的。**

业务补偿模式最大的缺点是**软状态的时间比较长，既数据一致性的时效性很低，多个服务常常可能处于数据不一致的情况。**

### TCC模式（无补偿记录）

![image-20201202165614646](/Users/yangyibo/Library/Application Support/typora-user-images/image-20201202165614646.png)

TCC模式是一种优化了的业务补偿模式，它可以做到**完全补偿**，既进行**补偿后不留下补偿的纪录**，就好像什么事情都没有发生过一样。同时，**TCC的软状态时间很短**，原因是因为**TCC是一种两阶段型模式**，只有在所有的服务的第一阶段（try）都成功的时候才进行第二阶段确认（Confirm）操作，否则进行补偿(Cancel)操作，而在try阶段是不会进行真正的业务处理的。

具体流程为两个阶段：

1. Try，业务服务完成所有的业务检查，预留必需的业务资源
2. 如果Try在所有服务中都成功，那么执行Confirm操作，Confirm操作不做任何的业务检查（因为try中已经做过），只是用Try阶段预留的业务资源进行业务处理；否则进行Cancel操作，Cancel操作释放Try阶段预留的业务资源。

TCC模式跟纯业务补偿模式相比，需要每个服务都需要实现**Confirm和Cancel两个接口**，因此落地实施上比纯业务补偿模式复杂一些，但好处是**数据一致的实时性高**，因此其在很多金融、电商场景中大量采用。

在事务补偿方案中，由于上游服务依赖于下游服务的结果，考虑到上下游服务间网络有可能是不稳定的，因此业务接口、补偿接口（Saga模式中）和Try接口、Confirm接口、Cancel接口（TCC模式中）均有可能会被多次调用，因此这些接口**在实现时需要考虑幂等性**。

幂等性的实现方式可以是：

1、**通过唯一键值做处理，即每次调用的时候传入唯一键值**，通过唯一键值判断业务是否被操作，如果已被操作，则不再重复操作

2、通**过状态机处理，给业务数据设置状态，通过业务状态判断是**否需要重复执行

**TCC 是一种服务层面上的 2PC，它是如何解决 2PC 无法应对宕机问题的缺陷的呢**？

答案是不断重试。由于 try 操作锁住了全局事务涉及的所有资源，保证了业务操作的所有前置条件得到满足，因此无论是 confirm 阶段失败还是 cancel 阶段失败都能通过不断重试直至 confirm 或 cancel 成功（所谓成功就是所有的服务都对 confirm 或者 cancel 返回了 ACK）。

TCC 由支付宝团队提出，被广泛应用于金融系统中。我们用银行账户余额购买基金时，会注意到银行账户中用于购买基金的那部分余额首先会被冻结，由此我们可以猜想，这个过程大概就是 TCC 的第一阶段。



参考：

https://mp.weixin.qq.com/s/Ha28YyFtuUxKO-_wEkWkNg

https://mp.weixin.qq.com/s/XBq0aftC_Q_yJ0VXu8fkwQ