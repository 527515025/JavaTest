# 操作


Linux常用命令 & 实用命令万字总结
https://mp.weixin.qq.com/s/nFayZVwAmCqzFshFPqNraA



Vmware vSphere Client安装redhat7.4虚拟机教程

```
http://blog.csdn.net/yangs_2012/article/details/78784764
https://jingyan.baidu.com/article/90808022f92fdcfd91c80faf.html
```

##查看redhat ip

```
ip addr 
```

##查看LInux 的文件编码

```
$ file -i tivoli_eif_zyb.log
tivoli_eif_zyb.log: text/plain; charset=utf-8
```

##修改Linux 的静态ip

```
/etc/sysconfig/network-scripts/ifcfg-eth0

 BOOTPROTO=static
 IPADDR=192.168.100.5 #静态IP    
 
 NETMASK=255.255.255.0 #子网掩码    
 GATEWAY=192.168.100.1 #默认网关 
 ONBOOT=yes
```

rhel7 断网 注释GATEWAY=192.168.100.1

##redhat7.1 网卡设置

ifcfg-ens32 网卡文件 配置静态ip
ifcfg-lo 本地网卡配置文件 应该配置为127.0.0.1

##Linux解决Device eth0 does not seem to be present 

解决办法：

首先，打开/etc/udev/rules.d/70-persistent-net.rules内容如下面例子所示：

```
# vi /etc/udev/rules.d/70-persistent-net.rules
# This file was automatically generated by the /lib/udev/write_net_rules
# program, run by the persistent-net-generator.rules rules file.
#
# You can modify it, as long as you keep each rule on a single
# line, and change only the value of the NAME= key.
# PCI device 0x1022:0x2000 (pcnet32)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:0c:29:8f:89:9
7", ATTR{type}=="1", KERNEL=="eth*", NAME="eth0"
# PCI device 0x1022:0x2000 (pcnet32)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:0c:29:50:bd:1
7", ATTR{type}=="1", KERNEL=="eth*", NAME="eth1"

记录下，eth1网卡的mac地址00:0c:29:50:bd:17

接下来，打开/etc/sysconfig/network-scripts/ifcfg-eth0

# vi /etc/sysconfig/netwonrk-scripts/ifcfg-eth0

将 DEVICE="eth0"  改成  DEVICE="eth1"  ,
将 HWADDR="00:0c:29:8f:89:97" 改成上面的mac地址  HWADDR="00:0c:29:50:bd:17"

最后，重启网络

# service network restart
redhat 7 用
systemctl restart network.service  
```

参考：http://www.linuxidc.com/Linux/2012-12/76248.htm

##redhat6.5修改主机名

```
vi /etc/sysconfig/network
修改HOSTNAME项
HOSTNAME=XXX
reboot
```

## redhat7.1 修改主机名

```
vi /etc/hostname
poc-kafka3-87
```

##配置Linux 联网

编辑 /etc/resolv.conf 添加内容如下：

```
nameserver 8.8.8.8
nameserver 8.8.4.4
```

##查看Linux版本

```
uname -a 
或
cat /proc/version
或
cat /etc/redhat-release  
或 
cat /etc/issue     －－redhat 6.5 一下。
或
cat /etc/redhat-release
```

## 查看LInux cpu

```
  cat /proc/cpuinfo |grep "model name" && cat /proc/cpuinfo |grep "physical id"

```

## 查看内存

```
cat /proc/meminfo |grep MemTotal
```

## linux 关闭防火墙

### rhel 7.1 关闭防火墙

```
systemctl stop firewalld.service
systemctl disable firewalld.service	
systemctl status firewalld.service
```

### rhel 6.5 关闭防火墙

* 关闭防火墙-----service iptables stop
* 启动防火墙-----service iptables start
* 重启防火墙-----service iptables restart
* 查看防火墙状态--service iptables status
* 永久关闭防火墙--chkconfig iptables off
* 永久关闭后启用--chkconfig iptables on
* 最后两个命令同时运行，运行完成后查看防火墙关闭状态 
* service iptables status

##linux rpm包下载

http://vault.centos.org/6.3/os/x86_64/Packages/
http://rpm.pbone.net/index.php3

##rpm 包命令

```
安装rpm  
rpm -ivh

--force 参数为重复替换
--nodeps 参数为强制安装，忽略依赖

列出rpm包的内容：
rpm -qpl *.rpm

解压rpm包的内容：（没有安装，就像解压tgz包一样rpm包）
rpm2cpio *.rpm | cpio -div

删除rpm包 
rpm -e <包的名字>
```

##linux 修改时区

1. 执行tzselect命令-->选择Asia-->选择China-->选择east China - Beijing, Guangdong, Shanghai, etc-->然后输入1

   如果不想用tzselect命令，可以修改文件变更时区。  vi /etc/sysconfig/clock  

   ```
   ZONE=Asia/Shanghai（查/usr/share/zoneinfo下面的文件） 
   UTC=false 
   ARC=false
   ```

2. rm /etc/localtime3、链接到上海时区文件       

3. ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime  重启机器

##Linux 修改时间

date -s "2017-06-15 09:55:25"
date -s "09:55:25"

##Linux 获取系统当前时间戳：

```
current=`date "+%Y-%m-%d %H:%M:%S"`  
timeStamp=`date -d "$current" +%s`   
#将current转换为时间戳，精确到毫秒  
currentTimeStamp=$((timeStamp*1000+`date "+%N"`/1000000)) 
echo $currentTimeStamp

```


##Redhat7.1

vi /etc/hostname
hostnamectl set-hostname your_hostname 
修改 redhat 7.1 的hostname

##创建新用户

#### useradd  -d /usr/cpic -m cpic (- 复制转译可能有误)

此命令创建了一个用户cpic，
其中-d和-m选项用来为登录名cpic产生一个主目录/usr/cpic（/usr为默认的用户主目录所在的父目录）。
useradd testuser 创建用户testuser
passwd cpic 给已创建的用户testuser设置密码

#### useradd -s /bin/sh -g group –G adm,root gem (- 复制转译可能有误)

此命令新建了一个用户gem，该用户的登录Shell是/bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。
这里可能新建组：#groupadd group及groupadd adm　
增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。
Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。

####userdel testuser 删除用户testuser

####rm -rf testuser 删除用户testuser所在目录

##修改普通用户的环境变量

vi .bashrc
source .bashrc


```
export JAVA_HOME=/usr/cpic/apps/jdk1.8.0_121
export PATH=$JAVA_HOME/bin:$PATH
```

#shell

eval命令将会首先扫描命令行进行所有的替换，憨厚再执行命令。

##shell生成随机数

生成1-60 的随机数

```
 #!/bin/bash
 
 echo "$((($RANDOM)%60))"
```

##判断上一条命令是否执行成功

```
if [ $? -eq 0 ];
then
	echo "执行成功";
else
	echo "执行失败";
fi
```

##shell 判断

```
#!/bin/sh
myPath="/var/log/httpd/"
myFile="/var /log/httpd/access.log"

# 这里的-x 参数判断$myPath是否存在并且是否具有可执行权限
if [ ! -x "$myPath"]; then
 mkdir "$myPath"
fi
# 这里的-d 参数判断$myPath是否是一个目录
if [ ! -d "$myPath"]; then
 mkdir "$myPath"
fi

# 这里的-f参数判断$myFile 文件是否存在
if [ ! -f "$myFile" ]; then
 touch "$myFile"
fi

# 这里的-s参数判断$myFile 判断文件存在且非空 
if [ ! -s "$myFile" ]; then
 touch "$myFile"
fi

# 其他参数还有-n,-n是判断一个变量是否是否有值 如果string 非空(非0），返回0(true)  
if [ ! -n "$myVar" ]; then
 echo "$myVar is empty"
 exit 0
fi

# 这里的-z 参数判断$myPath是否为空
if [ ! -z "$myPath"]; then
 mkdir "$myPath"
fi

# 两个变量判断是否相等
if [ "$var1" = "$var2" ]; then
 echo '$var1 eq $var2'
else
 echo '$var1 not eq $var2'
fi



#-eq  -ne  -lt  -nt只能用于整数，不适用于字符串，字符串等于用赋值号=
if [ int1 -eq int2 ]    如果int1等于int2   
if [ int1 -ne int2 ]    如果不等于    
if [ int1 -ge int2 ]       如果>=
if [ int1 -gt int2 ]       如果>
if [ int1 -le int2 ]       如果<=
if [ int1 -lt int2 ]       如果<

```

##从终端读取参数

-t 30 等待30s

-p "The para is params "  // 提示信息

```
#!/bin/sh
params=0;
#Read the params . Set The finalEnv. Pay Attention 'read' NOT 'Read'
read -t 30 -p "The para is params " params ;
echo "$params"
```

##从配置文件中读取数据

env.properties

```
flume_path=/opt/apps/wh.agent/current
epp_path=/opt/apps/epp_manager

prop_package=epp-manager
prop_appRoot=/opt/apps
```

注意：参数名不要用点隔开，应用下划线。 //test.sh

```
#!/bin/sh
. env.properties
finalPackage=${flume_path}
echo "$finalPackage"
```

##从配置文件中读取（二）

```
	VALUES=`grep "^flume_path" env.properties|grep -v \# |cut -d'=' -f2`;

```

通过查询的方式获取参数 ，^ 以此为开头。 grep -v \# 忽略以＃开头的记录

##wc  文件名   

- c 统计字节数。  

- l 统计行数。  

- w 统计字数。  

 该命令统计给定文件中的字节数、字数、行数。如果没有给出文件名，则从标准输入读取。wc同时也给出所有指定文件的总统计数。字是由空格字符区分开的最大字符串。  

##数组

```
#declare -a: define an array
#declare -i: define an integer
declare -i index=1
declare -a envMap
declare -a formatMap=(["1"]="docker" ["2"]="springboot")


#scan the env  all dir to envMap
for i in env/* ; do 
 if [ -d ${i} ]; then
	envMap["${index}"]="`basename ${i}`"
	index=index+1
 fi
done

#使用@ 或 * 可以获取数组中的所有元素
#print envMap all element
for i in ${!envMap[@]} ;do
	echo [${i}]:${envMap[${i}]}
done

```

##shell运算符

```
==	相等。用于比较两个数字，相同则返回 true。	[ $a == $b ] 返回 false。

-eq	检测两个数是否相等，相等返回 true。	[ $a -eq $b ] 返回 false。

=	检测两个字符串是否相等，相等返回 true。	[ $a = $b ] 返回 false。

!=	检测两个字符串是否相等，不相等返回 true。	[ $a != $b ] 返回 true。

-z	检测字符串长度是否为0，为0返回 true。	[ -z $a ] 返回 false。

-n	检测字符串长度是否为0，不为0返回 true。	[ -n $a ] 返回 true。

-d file	检测文件是否是目录，如果是，则返回 true。	[ -d $file ] 返回 false。

-f file	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。	[ -f $file ] 返回 true。
```

##egrep

Linux egrep命令用于在文件内查找指定的字符串。
egrep执行效果与"grep-E"相似，使用的语法及参数可参照grep指令，与grep的不同点在于解读字符串的方法。
egrep是用extended regular expression语法来解读的，而grep则用basic regular expression 语法解读，extended regular expression比basic regular expression的表达更规范。

```
egrep [范本模式] [文件或目录] 
egrep Linux * 
 //查找当前目录下所有文件中包含字符串"Linux"的文件
```

##echo -e

```
echo -e "OK! \n" # -e 开启转义

echo "$NAME"   #此时 $NAME 取变量值
echo '$NAME'  #此时把$NAME 当作字符串输出
echo '"$NAME"'  #此时把$NAME 当作字符串输出

```

##sed -i

Linux sed命令是利用script来处理文本文件。
sed可依照script的指令，来处理、编辑文本文件。
Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。

####选项与参数：

* -n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。
* -e ：直接在命令列模式上进行 sed 的动作编辑；
* -f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；
* -r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)
* -i ：直接修改读取的文件内容，而不是输出到终端。

####function：

* a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
* c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
* d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
* i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
* p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
* s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！

```
sed -i 's/原字符串/新字符串/' /home/1.txt
sed -i 's/原字符串/新字符串/g' /home/1.txt
#原串支持正则匹配哦。 ？ 为sed 的分隔符 # 和 / 也可以作为 sed 命令的分隔符
sed -i 's?^db.jdbc.url=.*?db.jdbc.url='$url'?' ../conf/application.properties;
```

##sh -c  "。。。"

从String中读取命令 并处理他们

##curl 

-d 传递参数 -o将输出重定向到一个文件（多用于下载文件）-s curl 在安静模式下执行，不会发送任何数据到stdout

```
curl -d "status=pedding" -o /dev/null -s $URL
```

##redhat ssh免密登录

B 机的.ssh 文件夹要是 通过 ssh-keygen -t rsa 命令创建的，因为redhat 的 ssh 文件夹用命令生成的，和手动生成的权限不一样（应该改为600 权限）。所以ssh 免密登录时有坑

```
在B机之行
ssh-keygen -t rsa
cp id_rsa.pub authorized_keys
chmod 600 authorized_keys

拷贝A 机的 id_rsa.pub 到B机的authorized_keys 中
此时可以从A 机免密登录B机
```


##redhat7.4 ssh免密无效

redhat7.4 默认没有启动 ssh 无密登录，修噶 /etc/ssh/sshd_config 其中 的2 行配置如果不存在则添加，每台服务器都要设置。(此操作用root 账户)

```
RSAAuthentication yes
PubkeyAuthentication yes
```

ssh配置文件位置 
修改后重启(此操作用root 账户)
service sshd restart

##截取字符串

shell 字符串截取

```
${varible##*string} 从左向右截取最后一个string后的字符串
${varible#*string}从左向右截取第一个string后的字符串
${varible%%string*}从右向左截取最后一个string后的字符串
${varible%string*}从右向左截取第一个string后的字符串
```

例子：获取test 输出结果 reserved. 后的字符串

```
#!bin/sh
re=`sh test.sh`
echo "${re##*reserved. }"
```

##脚本

###读取界面输入的数值。

read -t 30 -p "The username of the machine to be ssh .(default:root)" usernameTmp ;
读取界面输入的数值。
-t 30 为停留 30S
-p 是输出提示
usernameTmp 为接收的参数

###dirname

```
【`】，学名叫“倒引号”， 如果被“倒引号”括起来，  表示里面需要执行的是命令。
比如 `dirname $0`，  就表示需要执行   dirname $0  这个命令

在命令行状态下单纯执行 $ cd `dirname $0` 是毫无意义的。因为他返回当前路径的"."。
这个命令写在脚本文件里才有作用，他返回这个脚本文件放置的目录，并可以根据这个目录来定位所要运行程序的相对位置（绝对位置除外
```

###basename

```
`basename ${i}`
1、basename
该命令的作用是从路径中提取出文件名，使用方法为basename NAME [SUFFIX]。

1）从路径中提出出文件名（带后缀），例子如下：
￼
```

###getopts

由于shell命令行的灵活性，自己编写代码判断时，复杂度会比较高。使用内部命令 getopts 可以很方便地处理命令行参数。

getopts 的设计目标是在循环中运行，每次执行循环，getopts 就检查下一个命令行参数，并判断它是否合法。即检查参数是否以 - 开头，后面跟一个包含在 options 中的字母。如果是，就把匹配的选项字母存在指定的变量 variable 中，并返回退出状态0；如果 - 后面的字母没有包含在 options 中，就在 variable 中存入一个 ？，并返回退出状态0；如果命令行中已经没有参数，或者下一个参数不以 - 开头，就返回不为0的退出状态。

```
while getopts h:ms option
do 
    case "$option" in
     	 h)
            echo "option:h, value $OPTARG"
            echo "next arg index:$OPTIND";;
        m)
            echo "option:m"
            echo "next arg index:$OPTIND";;
        s)
            echo "option:s"
            echo "next arg index:$OPTIND";;
 esac  
done 
    
调用 ./args -h 100 -ms
```

getopts 允许把选项堆叠在一起（如 -ms）

2.如要带参数，须在对应选项后加 :（如h后需加参数 h:ms）。此时选项和参数之间至少有一个空白字符分隔，这样的选项不能堆叠。

3.如果在需要参数的选项之后没有找到参数，它就在给定的变量中存入 ? ，并向标准错误中写入错误消息。否则将实际参数写入特殊变量 ：OPTARG

4.另外一个特殊变量：OPTIND，反映下一个要处理的参数索引，初值是 1，每次执行 getopts 时都会更新。

## 概念

#Linux

##linux cgroup

Linux CGroup全称Linux Control Group， 是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）

最早的名称为进程容器（process containers）。在2007年时，因为在Linux内核中，容器（container）这个名词太过广泛，为避免混乱，被重命名为cgroup，


##!/bin/sh 与 !/bin/bash

/bin/sh 与 /bin/bash 虽然大体上没什么区别, 但仍存在不同的标准. 标记为 “#!/bin/sh” 的脚本不应使用任何 POSIX 没有规定的特性 (如 let 等命令, 但 “#!/bin/bash” 可以). Debian 曾经采用 /bin/bash 更改 /bin/dash，目的使用更少的磁盘空间、提供较少的功能、获取更快的速度。但是后来经过 shell 脚本测试存在运行问题。因为原先在 bash shell 下可以运行的 shell script (shell 脚本)，在 /bin/sh 下还是会出现一些意想不到的问题，不是100%的兼用。

linux查看内存占用情况  top 命令

## dump

 从正在运行的Linux进程中dump出内存内容