# GET和POST

##MVC

MVC本来是存在于Desktop程序中的，M是指数据模型，V是指用户界面，C则是控制器。使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。

##"GET方式提交的数据最多只能是1024字节"?  错

因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。

Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为"GET"，实质上，GET和POST只是发送机制不同，并不是一个取一个发！

##GET & POST

GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。

GET和POST是什么?HTTP协议中的两种发送请求的方法。
**HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接**。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。


##GET & POST 重大区别

GET产生一个TCP数据包;POST产生两个TCP数据包。

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。

也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。

1. GET与POST都有自己的语义，不能随便混用。
2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。
3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

##PUT

在HTTP中，PUT被定义为idempotent的方法，POST则不是，这是一个很重要的区别。

PUT操作是幂等的。所谓幂等是指不管进行多少次操作，结果都一样。比如我用PUT修改一篇文章，然后在做同样的操作，每次操作后的结果并没有不同

##汽车TCP

在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。

##交通规则HTTP 

HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签(设置method为GET)，而且要求把传送的数据放在车顶上(url中)以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩;也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。

##运输公司 浏览器

不同的浏览器(发起http请求)和服务器(接受http请求)就是不同的运输公司。

虽然理论上，你可以在车顶上无限的堆货物(url中无限加参数)。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，(大多数)浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。

# HTTP 

HTTP 超文本传输协议 (HTTP-Hypertext transfer protocol) 是一种基于文本的传输协议，详细规定了浏览器和万维网服务器之间互相通信的规则，过因特网传送万维网文档的数据传送协议。它位于 OSI 网络模型中的应用层。

HTTP通过**客户端和服务器的请求应答来进行通讯**，目前协议由之前的 RFC 2616 拆分成立六个单独的协议说明（RFC 7230、RFC 7231、RFC 7232、RFC 7233、RFC 7234、RFC 7235），通讯报文如下：

## OSI的七层网络结构 

OSI的七层网络结构模型（虽然实际应用中基本上都是五层），它可以分为以下几层：（从上到下）

- 第一层：应用层。定义了用于在网络中进行通信和传输数据的接口；允许访问OSI环境的手段（应用协议数据单元APDU）
- 第二层：表示层。定义不同的系统中数据的传输格式，编码和解码规范、加解密等；
- 第三层：会话层。管理用户的会话，控制用户间逻辑连接的建立和中断；
- 第四层：传输层。管理着网络中的端到端的数据传输；提供端到端的可靠报文传递和错误恢复（段Segment）
- 第五层：网络层。定义网络设备间如何传输数据；负责数据包从源到宿的传递和网际互连（包PackeT）
- 第六层：链路层。将上面的网络层的数据包封装成数据帧，便于物理层传输；将比特组装成帧和点到点的传递（帧Frame）
- 第七层：物理层。这一层主要就是传输这些二进制数据。通过媒介传输比特,确定机械及电气规范（比特Bit）

**TCP/IP分层（4层）**：网络接口层、 网际层、运输层、 应用层。

**五层协议 （5层）**：物理层、数据链路层、网络层、运输层、 应用层。

实际应用过程中，五层协议结构里面是没有**表示层和会话层的。应该说它们和应用层合并了**。我们应该将重点放在应用层和传输层这两个层面。因为**HTTP是应用层协议**，而**TCP是传输层协议**

**每一层的协议如下：**

物理层：RJ45、CLOCK、IEEE802.3   （中继器，集线器，网关）；

数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机）；

网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）；

传输层：TCP、UDP、SPX；

会话层：NFS、SQL、NETBIOS、RPC；

表示层：JPEG、MPEG、ASII；

应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS；**RPC服务**

### HTTP 中间人攻击

HTTP 协议使用起来确实非常的方便，但是它存在一个致命的缺点：不安全。

我们知道 HTTP 协议中的报文都是以明文的方式进行传输，不做任何加密。在 HTTP 传输过程中，中间人能看到并且修改 HTTP 通讯中所有的请求和响应内容，所以使用 HTTP 是非常的不安全的。

1.  攻防：**防止中间人攻击将报文加密**AES加密算法，如果第一次通信被拦截到了，那么秘钥就会泄露给中间人，中间人仍然可以解密后续的通信。

2. 防：采用**非对称加密**，我们可以通过 RSA 算法来实现。由服务器生成一对公私钥，服务器将公钥返回给客户端，客户端本地生成一串秘钥(AES_KEY)用于对称加密，并通过服务器发送的公钥进行加密得到(AES_KEY_SECRET)，之后返回给服务端，服务端通过私钥将客户端发送的AES_KEY_SECRET进行解密得到AEK_KEY,最后客户端和服务器通过AEK_KEY进行报文的加密通讯

3. 攻：中间人为了对应这种加密方法又想出了一个新的破解方案，既然拿不到AES_KEY，那我就**把自己模拟成一个客户端和服务器端的结合体**，在用户->中间人的过程中中间人模拟服务器的行为，这样可以拿到**用户请求的明文**，在中间人->服务器的过程中中间人模拟客户端行为，这样**可以拿到服务器响应的明文**。以此来进行中间人攻击，通信再次被中间人截获，中间人自己也伪造了一对公私钥，并将公钥发送给用户以此来窃取客户端生成的AES_KEY，在拿到AES_KEY之后就能轻松的进行解密了

##Https

HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），**是以安全为目标的HTTP通道，简单讲是HTTP的安全版**。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

HTTPS 其实是SSL+HTTP的简称,当然现在SSL基本已经被TLS取代了，不过我们还是统一以SSL作为简称，SSL协议其实不止是应用在HTTP协议上，还在应用在各种应用层协议上，例如：FTP、WebSocket。

其实SSL协议**大致就和上一节非对称加密**的性质一样，握手的过程中主要也是为了交换秘钥，然后再通讯过程中使用对称加密进行通讯，大概流程如下：


##http和https区别

https协议需要到ca申请证书，一般免费证书很少，需要交费。http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。http的连接很简单,是无状态的HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、

http的连接很简单,是无状态的。HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全



### 为什么用了 HTTPS 就是安全的？

### HTTPS 的底层原理如何实现？

### 用了 HTTPS 就一定安全吗？

大家可能都听说过 HTTPS 协议之所以是安全的是因为 HTTPS 协议会对传输的数据进行加密，而加密过程是使用了**非对称加密实现**。但其实，**HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段**。

HTTPS 的整体过程分为证书验证和数据传输阶段，

证书验证阶段：

- 浏览器发起 HTTPS 请求。
- 服务端返回 HTTPS 的 ssl 证书。通过 SSL 证书来传递公钥
- 客户端验证ssl证书是否合法，如果不合法则提示告警。证书认证体系就是确保SSL安全的关键

数据传输阶段：

- 当证书验证合法后，在本地生成随机数。
- 通过公钥加密随机数，并把加密后的随机数传输到服务端。
- 服务端通过私钥对随机数进行解密。
- 服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输。

### CA认证体系

客户端是通过 权威认证机构 校验服务器 SSL 证书的安全性。

在 CA 认证体系中，所有的证书都是由权威机构来颁发，而权威机构的 CA 证书都是已经在操作系统中内置的，我们把这些证书称之为CA根证书。

**签发证书**

我们的**应用服务器**如果想要使用 SSL 的话，需要**通过权威认证机构来签发CA证书**，我们**将服务器生成的公钥和站点相关信息发送给CA签发机构**，再由CA签发机构通过服务器发送的相关信息用CA签发机构进行加签，由此得到我们**应用服务器的证书**，证书会对应的生成证书内容的签名，并将该签名使用CA签发机构的**私钥**进行**加密得到证书指纹**，并且与上级证书生成关系链。

**如何验证服务器证书**

那么客户端(浏览器)又是如何对服务器证书做校验的呢，首先会**通过层级关系找到上级证书**，通过上级证书里的**公钥**来对服务器的**证书指纹进行解密**得到签名(sign1)，再通过签名算法算出服务器证书的签名(sign2)，通过对比sign1和sign2，如果相等就说明证书是没有被篡改也不是伪造的。

证书校验用的 RSA 是通过私钥加密证书签名，公钥解密来巧妙的验证证书有效性。

这样通过证书的认证体系，我们就可以避免了中间人窃取AES_KEY从而发起拦截和修改 HTTP 通讯的报文。

### 为什么数据传输是用对称加密？

首先，**非对称加密的加解密效率是非常低**的，而 HTTP 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。

另外，在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。

### 总结：

https 首先传递ssl证书和验证证书，非堆成加密

数据传输堆成加密

[为什么 HTTPS 是安全的？][https://mp.weixin.qq.com/s/YxmmwwZtiMFFfhgoYZzqwQ]

#  UDP 和 TCP

### UDP

数据结构也很简单，不需要大量的数据结构、处理逻辑、包头字段

不会建立连接，有个端口号，谁都可以监听这个端口号往上面发数据。也可以从这个端口号传给任何人数据

不会根据网络情况进行拥塞控制。无论网络丢包多严重，我还是照样发~

需要资源少，适合网络情况比较好的内网，或者对于丢包不敏感的应用。

不需要一对一沟通来建立连接，可以广播的应用。

主要应用在需要处理速度快，时延低，可以容忍少数丢包的情况。即使网络情况不佳，发包就是~。UDP 常用在实时竞技游戏，IoT 物联网，移动通信领域。

### TCP

TCP 是面向连接的，三次握手，四次挥手。UDP 是面向无连接。

面向连接

**面向连接**，就是为了**在客户端和服务端维护连接**，而建立**一定的数据结构来维护双方交互的状态**，用这样的数据来保证所谓的面向连接的特性

TCP 提供**可靠交付**，通过 TCP 连接传输的数据，可以无差错、不丢失、不重复、并且**按序**到达。而 **UDP 继承了 IP 包**的特性，**不保证不丢失，不保证按顺序到达**。

面向字节流

TCP 是面向字节流，所谓字节流，就是发的是一个流，没头没尾。TCP 自己维护流状态。

UDP 基于 IP 数据报，一个一个地发，一个一个地收。

* 拥塞控制

TCP 拥有拥塞控制，如果包丢弃了或者网络环境不好了，就会根据网络情况自行控制自己的行为，看下是发快点还是发慢点。

UDP 则没有这么智能了， 你让我发，我就发呗，反正是你让我发的，其他的一概不管~

* 有状态服务

TCP 是一个有状态的服务，有状态可以理解为：我记录了哪些发送了，哪些没有发送，哪些接收到了，哪些没接收到，应该接收哪个了，一点差错都不行。

而 UDP 则不是有状态的服务，我只管发，其他的就交给接收端。

## **如何让 UDP 实现 TCP 功能**？

1，建立连接上面已经讲到了，三次握手和四次握手，UDP 也可以模拟去做。

- 顺序问题
- 丢包问题
- 流量控制
- 拥塞控制

**顺序问题和丢包问题**可以利用**确认**与**重发**的机制。假如包收到了，可以做一个确认，发送一个 ACK 给发送端，告诉他我收到了。假如**有的包提前到了，就缓存**着。假如有包丢失了，就可以超时重试。超时重试不宜过短，时间必须大于往返时间 RTT，否则会引起不必要的重传。也不宜过长，如果超时时间过长，访问就变慢了。那怎么**确定这个时间，可以通过采样 RTT 的时间，进行加权平均**。还需要根据网络状况，动态变化。可以了解下**自适应重传算法**。

**流量控制**就是根据网络情况调整发包的速率。利用的是滑动窗口。在对于包的确认中，同时会携带一个窗口的大小，只要利用好这个窗口大小，就能很好地调整发包速率，发的报文段不要超过窗口的大小就 OK

**拥塞控制**主要用来避免**包丢失和超时重传**，如果出现了这两种现象，就说明发的速率太快了。其实开始时只发送一个报文段数据，如果收到一个确认，则倍增报文段，依次类推。当**发现超时重传时，就又回到只发送一个报文段的情况**，这个就是慢启动，这种方式不合适。其实还有一种快速重传算法，简单来说就是**拥塞窗口减半，后续线性增速**。针对于算法怎么实现的，这里就不展开讲述了。

至此，我用大白话的方式讲解了 UDP 和 TCP 的区别，以及 UDP 缺什么功能，需要怎么去弥补才能实现 TCP 的功能。相信这样回答的思路可以让面试官觉得还是有点东西的。











从三个角度来介绍RPC服务：分别是RPC架构，同步异步调用以及流行的RPC框架。

