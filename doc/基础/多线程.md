#java多线程

## 

##synchronized 

* synchronized修饰非静态方法、同步代码块的synchronized (this)用法和synchronized (非this对象)的用法锁的是对象，线程想要执行对应同步代码，需要获得对象锁。     
* synchronized**修饰静态方法以及同步代码块的synchronized (类.class)用法锁的是类**，线程想要执行对应同步代码，需要获得类锁。
* 在java中，同步加锁的是一个对象或者一个类，而不是代码

对于synchronized关键字而言，javac在编译时，会生成对应的**monitorenter和monitorexit指令**分别对应synchronized同步块的进入和退出，有**两个monitorexit指令的原因是：为了保证抛异常的情况下也能释放锁**，所以javac为同步代码块添加了一个隐式的try-finally，在**finally中会调用monitorexit命令释放锁**。在JVM底层，对于这两种synchronized语义的实现大致相同

对于synchronized方法而言，javac为其生成了一个**ACCSYNCHRONIZED**关键字，在JVM进行方法调用时，发现调用的方法被ACCSYNCHRONIZED修饰，则会先尝试获得锁

### 锁的几种形式

传统的锁（也就是下文要说的**重量级锁**）依赖于**系统的同步函数**，在linux上使用**mutex互斥锁**，最底**层实现依赖于futex**，关于futex可以看这些文章，这**些同步函数都涉及到用户态和内核态的切换**、**进程的上下文切换，成本较高**。对于加了synchronized关键字但运行时并没有多线程竞争，或**两个线程接近于交替执行的情况，使用传统锁机制无疑效率是会比较低的**。

JDK 1.6之前,synchronized只有传统的锁机制。

JDK 1.6引入了两种新型锁机制：**偏向锁和轻量级锁**，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销问题。

https://mp.weixin.qq.com/s/zaazbtl3_PCwaRqK2gy_Lw





####  轻量级锁解锁过程

遍历线程栈，找到对象的 markword 中记录的lock record ，且检查 lockrecord 的 obj 指针 指向的 对象地址是等于需解锁对象。使用原子的CAS将lock record 的 Displaced MarkWord 替换回对象头，如果成功，则表示没有竞争发生，如果替换失败则升级为重量级锁。

##synchronized 使用

synchronized关键字可标记四种代码块：

1. 实例方法
2. 静态方法
3. 实例方法中的代码块
4. 静态方法中的代码块

##有了 synchronized **那么为什么会出现Lock呢？**

　　synchronized是java中的一个关键字，是管程（monitor）的一个实现，也就是说是Java语言内置的特性。**那么为什么会出现Lock呢？**

　如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：

　　1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；

　　2）线程执行发生异常，此时JVM会让线程自动释放锁。

　　那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，影响程序执行效率。所以就搞了个Lock

Lock搞了3种方法来破环不可抢占的条件。
1、`void lockInterruptibly() throws InterruptedException;` 这是个支持中断的API。Synchronized进入阻塞之后就没办法唤醒它，所以针对这个问题想了个支持响应中断的方法，让线程阻塞(lock下是等待状态)的时候可以响应中断信号，从而有机会释放已占有的资源来破环不可抢占的条件。
2、`boolean tryLock();`这就是在获取锁的时候，如果获取不到就直接返回，这样也有机会释放已占有的资源来破环不可抢占的条件。
3、`boolean tryLock(long time, TimeUnit unit) throws InterrptedException;`这是个支持超时的API，也就是让在一段时间内获取不到资源的线程直接返回一个错误，不进入阻塞状态，那也有机会释放已占有的资源来破环不可抢占的条件。
然后再来说说Lock的实现类一共有三个，一个是ReentrantLock,另两个是ReentrantReadWriteLock类中的两个静态内部类ReadLock和WriteLock。实现思路大同小异。

##Lock 接口

lock：需要显示指定起始位置和终止位置。一般使用ReentrantLock类做为锁，多个线程中必须要使用一个ReentrantLock类做为对象才能保证锁的生效。且在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。

synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。

Lock接口中每个方法的使用

* lock()用来获取锁。如果锁已被其他线程获取，则进行等待。
* tryLock()如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待，则返回true。
* tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。
* lockInterruptibly()是用来获取锁的。如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。
* unLock()方法是用来释放锁的。

## condition

在使用Lock之前，我们使用的最多的同步方式应该是synchronized关键字来实现同步方式了。配合Object的wait()、notify()系列方法可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，但是这两者在使用方式以及功能特性上还是有差别的。Object和Condition接口的一些对比。

![锁condition与object方法对比](/Users/yangyibo/Documents/技能点/整理知识点图/锁condition与object方法对比.png)condition对象是依赖于lock对象的，意思就是说condition对象需要通过lock对象进行创建出来(调用Lock对象的newCondition()方法)。但是需要注意在调用方法前获取锁。

一般都会将Condition对象作为成员变量。当调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。

#### condition常用方法
   condition可以通俗的理解为**条件队列**。当一个线程在调用了await方法以后，**直到线程等待的某个条件为真的时候才会被唤醒**。这种方式为线程提供了更加简单的**等待/通知模式**。Condition必须要**配合锁一起使用**，因为对共享状态变量的访问发生在多线程环境下。一个**Condition的实例必须与一个Lock绑定**，因此Condition一般都是作为Lock的内部实现。

* await() ：造成当前线程在**接到信号或被中断之前**一直处于等待状态。
* await(long time, TimeUnit unit) ：造成当前线程在**接到信号、被中断或到达指定等待时间之前**一直处于等待状态
* awaitNanos(long nanosTimeout) ：造成当前线程在**接到信号、被中断或到达指定等待时间之前**一直处于等待状态。**返回值表示剩余时间**，如果在nanosTimesout之前唤醒，那么返回值 = nanosTimeout - 消耗时间，如果**返回值 <= 0 ,则可以认定它已经超时**了。
* awaitUninterruptibly() ：造成当前线程在**接到信号之前**一直处于等待状态。【注意：**该方法对中断不敏感**】。
* awaitUntil(Date deadline) ：造成当前线程在**接到信号**、**被中断或到达指定最后期限之前一直处于等待状态**。如果没有到指定时间就被通知，则返回true，否则表示到了指定时间，返回false。
* signal() ：**唤醒一个等待线程**。该线程从等待方法返回前必须获得与Condition相关的锁。
* signal()All ：**唤醒所有等待线程**。能够从等待方法返回的线程必须获得与Condition相关的锁。

#### condition原理：

 Condition是AQS的内部类。每个Condition对象都**包含一个队列(等待队列)**。等待队列是一个**FIFO的队列**，在队列中的**每个节点都包含了一个线程引用**，该线程就是在**Condition对象上等待的线程**，如果**一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态**。等待队列的基本结构如下所示。

![锁condition结构](/Users/yangyibo/Documents/技能点/整理知识点图/锁condition结构.png)

等待分为**首节点**和**尾节点**。当一个线程调用**Condition.await()**方法，将会以**当前线程**构造节点，并**将节点从尾部加入等待队列**。新增节点后将尾部节点换为新增的节点。节点引用更新本来就是在获取锁以后的操作，所以不需要CAS保证，也是线程安全的操作。

等待

当线程调用了await方法以后。**线程就作为队列中的一个节点被加入到等待队列中去了**。同时会释放锁的占用。当从await方法返回的时候。一定会获取condition相关联的锁。当等待队列中的节点被唤醒的时候，则**唤醒节点的线程开始尝试获取同步状态（锁）**。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException异常信息。

通知

调用Condition的signal()方法，将会**唤醒在等待队列中等待最长时间的节点**（条件队列里的**首节点**），在唤醒节点前，会将节点移到**同步队列**中，即可以去竞争获取锁，。当前线程加入到等待队列中如图所示：

![锁condition的signal](/Users/yangyibo/Documents/技能点/整理知识点图/锁condition的signal.png)

在调用signal()方法之前必须**先判断是否获取到了锁**。接着获取等待队列的**首节点**，将其移动到**同步队列**并且利用**LockSupport唤醒节点中的线程**。节点从等待队列移动到同步队列如下图所示：

![锁condition的signal变化](/Users/yangyibo/Documents/技能点/整理知识点图/锁condition的signal变化.png)

被唤醒的线程将从await方法中的while循环中退出。随后加入到同步状态的竞争当中去。成功获取到竞争的线程则会返回到await方法之前的状态。

#### condition 总结

调用await方法后，将当前线程加入Condition等待队列中。当前线程释放锁。否则别的线程就无法拿到锁而发生死锁。自旋(while)挂起，不断检测节点是否在同步队列中了，如果是则尝试获取锁，否则挂起。当线程被signal方法唤醒，被唤醒的线程将从await()方法中的while循环中退出来，然后调用acquireQueued()方法竞争同步状态。



##Java的锁分为对象锁和类锁。

     　　1. 当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内针对该对象的操作只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。
    
     　　2. 然而，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。
    
     　　3. 尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对该object中所有其它synchronized(this)同步代码块的访问将被阻塞。
    
     　　4. 同步加锁的是对象，而不是代码。因此，如果你的类中有一个同步方法，这个方法可以被两个不同的线程同时执行，只要每个线程自己创建一个的该类的实例即可。
    
     　　5. 不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法。
    
     　　6. synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法。

7.对一个全局对象或者类加锁时，对该类的所有对象都起作用

　　

##java线程池

###在什么情况下使用线程池？ 

* 1.单个任务处理的时间比较短 
* 2.需处理的任务的数量大 

###使用线程池的好处:

* 1.减少在**创建和销毁线程**上所花的时间以及系统资源的开销 
* 2.如不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内存

###线程池包括以下四个基本组成部分：

* 1、线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；
* 2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；
* 3、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；
* 4、任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。

###线程池的核心参数

ThreadPoolExecutor 有四个构造方法，前三个都是调用最后一个(最后一个参数最全)

```
 public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }

   
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             threadFactory, defaultHandler);
    }

  
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              RejectedExecutionHandler handler) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), handler);
    }

    // 都调用它
    public ThreadPoolExecutor(// 核心线程数
    int corePoolSize, 
                              // 最大线程数
                              int maximumPoolSize,  
                              // 闲置线程存活时间
                              long keepAliveTime,  
                              // 时间单位
                              TimeUnit unit, 
                              // 线程队列
                              BlockingQueue<Runnable> workQueue,  
                              // 线程工厂  
                              ThreadFactory threadFactory,                
                              // 队列已满,而且当前线程数已经超过最大线程数时的异常处理策略              
                              RejectedExecutionHandler handler   ) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }

```

* corePoolSize：核心线程数
  *  核心线程会一直存活，即使没有任务需要执行
  *  当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理
  *  设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭
* maxPoolSize：最大线程数
  * 当线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务
  * 当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常
* keepAliveTime：线程空闲时间
  * 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize
  * 如果allowCoreThreadTimeout=true，则会直到线程数量=0
* workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：
  * ArrayBlockingQueue;
  * LinkedBlockingQueue;
  * SynchronousQueue;
  * ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。
* threadFactory：线程工厂，主要用来创建线程；
* rejectedExecutionHandler：任务拒绝处理器，两种情况会拒绝处理任务：
  * 当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务
  * 当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务
* 当拒绝处理任务时线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常。ThreadPoolExecutor类有几个内部实现类来处理这类情况：
  * AbortPolicy 丢弃任务，抛运行时异常
  * CallerRunsPolicy 执行任务
  * DiscardPolicy 忽视，什么都不会发生
  * DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务
  * 实现RejectedExecutionHandler接口，可自定义处理器

###Java线程池 ExecutorService 的创建

* Executors.newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
* Executors.newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
* Executors.newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
* Executors.newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

备注：Executors只是一个工厂类，它所有的方法返回的都是ThreadPoolExecutor、ScheduledThreadPoolExecutor这两个类的实例。

###  springBoot 的使用配置

```
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 数据收集配置，主要作用在于Spring启动时自动加载一个ExecutorService对象.
 * @author Bruce
 * @date 2017/2/22
 * 
 * update by Cliff at 2027/11/03
 */
@Configuration
public class ThreadPoolConfig {

    @Bean
    public ExecutorService getThreadPool(){
        return Executors.newCachedThreadPool();
    }


}

```

###ExecutorService有如下几个执行方法

- executorService.execute(Runnable);这个方法接收一个Runnable实例，并且异步的执行
- executorService.submit(Runnable)
- executorService.submit(Callable)
- executorService.invokeAny(...)
- executorService.invokeAll(...)

###execute(Runnable)

这个方法接收一个Runnable实例，并且异步的执行

```
executorService.execute(new Runnable() {
public void run() {
    System.out.println("Asynchronous task");
}
});

executorService.shutdown();
```

###submit(Runnable)

submit(Runnable)和execute(Runnable)区别是前者可以返回一个Future对象，通过返回的Future对象，我们可以检查提交的任务是否执行完毕，请看下面执行的例子：

```
Future future = executorService.submit(new Runnable() {
public void run() {
    System.out.println("Asynchronous task");
}
});

future.get();  //returns null if the task has finished correctly.

```

###submit(Callable)

submit(Callable)和submit(Runnable)类似，也会返回一个Future对象，但是除此之外，submit(Callable)接收的是一个Callable的实现，Callable接口中的call()方法有一个返回值，可以返回任务的执行结果，而Runnable接口中的run()方法是void的，没有返回值。请看下面实例：

```
Future future = executorService.submit(new Callable(){
public Object call() throws Exception {
    System.out.println("Asynchronous Callable");
    return "Callable Result";
}
});

System.out.println("future.get() = " + future.get());
```

如果任务执行完成，future.get()方法会返回Callable任务的执行结果。注意，future.get()方法会产生阻塞。

###invokeAny(…)

invokeAny(...)方法接收的是一个Callable的集合，执行这个方法不会返回Future，但是会返回所有Callable任务中其中一个任务的执行结果。这个方法也无法保证返回的是哪个任务的执行结果，反正是其中的某一个。

```
ExecutorService executorService = Executors.newSingleThreadExecutor();

Set<Callable<String>> callables = new HashSet<Callable<String>>();

callables.add(new Callable<String>() {
public String call() throws Exception {
    return "Task 1";
}
});
callables.add(new Callable<String>() {
public String call() throws Exception {
    return "Task 2";
}
});
callables.add(new Callable<String>() {
    public String call() throws Exception {
    return "Task 3";
}
});

String result = executorService.invokeAny(callables);
System.out.println("result = " + result);
executorService.shutdown();
```

###invokeAll(…)

invokeAll(...)与 invokeAny(...)类似也是接收一个Callable集合，但是前者执行之后会返回一个Future的List，其中对应着每个Callable任务执行后的Future对象。

```
List<Future<String>> futures = executorService.invokeAll(callables);

for(Future<String> future : futures){
System.out.println("future.get = " + future.get());
}

executorService.shutdown();
```

https://www.cnblogs.com/dolphin0520/p/3932921.html
https://www.cnblogs.com/waytobestcoder/p/5323130.html

**ThreadLocal是什么**

从名字我们就可以看到ThreadLocal叫做线程变量，意思是ThreadLocal中填充的变量属于**当前**线程，该变量对其他线程而言是隔离的。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。 

## ReentrantLock

https://mp.weixin.qq.com/s/Vqpzg3mWIUEy1S7XW9s-gw

https://mp.weixin.qq.com/s/TQYOmT33j2Ixs_Geso4hWw

https://mp.weixin.qq.com/s/wsM4DTFz6n4PDI2XyyKX5Q





