# RPC

RPC（Remote Procedure Call Protocol）**远程过程调用协议**，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。简言之，**RPC使得程序能够像访问本地系统资源一样，去访问远端系统资源**。比较关键的一些方面包括：通讯协议、序列化、资源（接口）描述、服务框架、性能、语言支持等。

简单的说，RPC就是**从一台机器(客户端)上通过参数传递的方式调用另一台机器(服务器)上的一个函数或方法**(可以统称为服务)并得到返回的结果。

## PRC架构组件

一个基本的RPC架构里面应该至少包含以下4个组件：

1、**客户端**（Client）:服务调用方（服务消费者）

2、**客户端存根**（Client Stub）:存放**服务端地址信息**，将客户端的请求参数数据信息序列化（组装）打包成网络消息，再通过网络传输发送给服务端

3、**服务端存根**（Server Stub）:接收客户端发送过来的请求消息并进行解包（反序列化操作），然后再调用本地服务进行处理

4、**服务端**（Server）:服务的真正提供者，执行具体业务逻辑并将处理结果返回给服务端存根

### 执行过程

1、服务消费者（client客户端）通过调用本地服务的方式调用需要消费的服务；

2、客户端存根（client stub）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体；

3、客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端；

4、服务端存根（server stub）收到消息后进行解码（反序列化操作）；

5、服务端存根（server stub）根据解码结果调用本地的服务进行相关处理；

6、本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）；

7、服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方；

8、客户端存根（client stub）接收到消息，并进行解码（反序列化）；

9、服务消费方得到最终结果；

## RPC和SOA、SOAP、REST的区别

**1、REST**

可以看着是**HTTP协议的一种直接应用**，默认**基于JSON作为传输格**式,使用简单,学习成本低效率高,但是安全性较低。：springboot Cloud

**2、SOAP**

**SOAP是一种数据交换协议规范,**是一种轻量的、简单的、基于XML的协议的规范。而SOAP可以看着是一个重量级的协议，基于XML、SOAP在安全方面是通过使用XML-Security和XML-Signature两个规范组成了WS-Security来实现安全控制的,当前已经得到了各个厂商的支持 。：Web Service

它有什么优点？简单总结为：易用、灵活、跨语言、跨平台。

**3、SOA**

面向服务架构，它可以根据需求**通过网络对松散耦合的粗粒度应用组件进行分布式部署**、组合和使用。服务层是SOA的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。

SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型。SOA可以看作是B/S模型、XML（标准通用标记语言的子集）/Web Service技术之后的自然延伸。 dubbo

**4、REST 和 SOAP、RPC 有何区别呢?**

没什么太大区别，他们的本质都是提供可支持分布式的基础服务，最大的区别在于他们各自的的特点所带来的不同应用场景 。

## RPC框架需要解决的问题？

1、如何确定客户端和服务端之间的**通信协议**？

2、如何更高效地进行**网络通信**？

3、服务端提供的**服务如何暴露**给客户端？

4、客户端如何**发现这些暴露的服务**？

5、如何更高效地对请求对象和响应结果进行**序列化和反序列化操作**？

## RPC的实现基础？

1、需要有非常高效的网络通信，比如一般选择**Netty**作为网络通信框架；

2、需要有比较**高效的序列化**框架，比如谷歌的Protobuf序列化框架；

3、可靠的寻址方式（主要是**提供服务的发现**），比如可以使用Zookeeper来注册服务等等；

4、如果是带会话（状态）的RPC调用，还需要有会话和**状态保持**的功能；

## RPC使用了哪些关键技术？

**1、动态代理**

生成Client Stub（客户端存根）和Server Stub（服务端存根）的时候需要用到Java动态代理技术，可以使用JDK提供的原生的动态代理机制，也可以使用开源的：CGLib代理，Javassist字节码生成技术。

**2、序列化和反序列化**

在网络中，所有的数据都将会被转化为字节进行传送，所以为了能够使参数对象在网络中进行传输，需要对这些参数进行序列化和反序列化操作。

- 序列化：把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。
- 反序列化：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。

目前比较高效的开源序列化框架：如Kryo、FastJson和Protobuf等。

**3、NIO通信**

出于并发性能的考虑，传统的阻塞式 IO 显然不太合适，因此我们需要异步的 IO，即 NIO。Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的 NIO.2 支持。可以**选择Netty或者MINA来解决NIO数据传输**的问题。

**4、服务注册中心**

可选：Redis、Zookeeper、Consul 、Etcd。一般使用ZooKeeper提供服务注册与发现功能，解决单点故障以及分布式部署的问题(注册中心)。



## RPC框架需要解决的问题Dubbo的解决？

1、如何确定客户端和服务端之间的**通信协议**？

dubbo 提供 dubbo、rmi、webservice、http、hessian、memcache、redis

2、如何更高效地进行**网络通信**？

3、服务端提供的**服务如何暴露**给客户端？

zookeeper、redis

4、客户端如何**发现这些暴露的服务**？

zookeeper

5、如何更高效地对请求对象和响应结果进行**序列化和反序列化操作**？

hession、java序列化



**dubbo****：** 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，

以及消费者远大于提供者。传输协议 TCP，异步，Hessian 序列化；

 **rmi****：** 采用 JDK 标准的 rmi 协议实现，传输参数和返回参数对象需要实现

Serializable 接口，使用 java 标准序列化机制，使用阻塞式短连接，传输数

据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。

多个短连接，TCP 协议传输，同步传输，适用常规的远程服务调用和 rmi 互

操作。在依赖低版本的 Common-Collections 包，java 序列化存在安全漏

洞；

 **webservice****：** 基于 WebService 的远程调用协议，集成 CXF 实现，提供和

原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适

用系统集成和跨语言调用；

 **http****：** 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实

现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消

费者，需要给应用程序和浏览器 JS 调用；

 **hessian****：** 集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，

Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多

个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于

消费者，提供者压力较大，可传文件；

 **memcache****：** 基于 memcached 实现的 RPC 协议

 **redis****：** 基于 redis 实现的 RPC 协议



### dubbo 负载均衡

**Random LoadBalance:** 随机选取提供者策略，有利于动态调整提供者权

重。截面碰撞率高，调用次数越多，分布越均匀；

 **RoundRobin LoadBalance:** 轮循选取提供者策略，平均分布，但是存在请

求累积的问题；

 **LeastActive LoadBalance:** 最少活跃调用策略，解决慢提供者接收更少的

请求；

 **ConstantHash LoadBalance:** 一致性 Hash 策略，使相同参数请求总是发

到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避

免引起提供者的剧烈变动；



[看了这篇Dubbo RPC面试题，让天下没有难面的面试题][https://blog.csdn.net/xlgen157387/article/details/88746098]



# **RPC架构**

先说说RPC服务的基本架构吧。允许我可耻地盗一幅图哈~我们可以很清楚地看到，一个完整的RPC架构里面包含了四个核心的组件，分别是Client ,Server,Client Stub以及Server Stub，这个Stub大家可以理解为存根。分别说说这几个组件：

- 客户端（Client），服务的调用方。
- 服务端（Server），真正的服务提供者。
  客户端存根，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。
  服务端存根，接收客户端发送过来的消息，将消息解包，并调用本地的方法。

RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http一样去3次握手什么的，减少了网络开销；

其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。

## 优缺点

RPC服务和HTTP服务还是存在很多的不同点的，一般来说，RPC服务主要是针对大型企业的，而HTTP服务主要是针对小企业的，因为RPC效率更高，而HTTP服务开发迭代会更快。

