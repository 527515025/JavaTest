# RPC

RPC（Remote Procedure Call Protocol）**远程过程调用协议**，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。简言之，**RPC使得程序能够像访问本地系统资源一样，去访问远端系统资源**。比较关键的一些方面包括：通讯协议、序列化、资源（接口）描述、服务框架、性能、语言支持等。

简单的说，RPC就是**从一台机器(客户端)上通过参数传递的方式调用另一台机器(服务器)上的一个函数或方法**(可以统称为服务)并得到返回的结果。

## PRC架构组件

一个基本的RPC架构里面应该至少包含以下4个组件：

1、**客户端**（Client）:服务调用方（服务消费者）

2、**客户端存根**（Client Stub）:存放**服务端地址信息**，将客户端的请求参数数据信息序列化（组装）打包成网络消息，再通过网络传输发送给服务端

3、**服务端存根**（Server Stub）:接收客户端发送过来的请求消息并进行解包（反序列化操作），然后再调用本地服务进行处理

4、**服务端**（Server）:服务的真正提供者，执行具体业务逻辑并将处理结果返回给服务端存根

### 执行过程

1、服务消费者（client客户端）通过调用本地服务的方式调用需要消费的服务；

2、客户端存根（client stub）接收到调用请求后负责将方法、入参等信息**序列化（组装）成能够进行网络传输**的消息体；

3、客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端；

4、服务端存根（server stub）收**到消息后进行解码（反序列化操作**）；

5、服务端存根（server stub）根据解码结果**调用本地的服务进行相关处理**；

6、本地服务执行具体业务逻辑并**将处理结果返回给服务端存根**（server stub）；

7、服务端存根（server stub）**将返回结果重新打包成消息（序列化）并通过网络发送至消费方**；

8、客户端存根（client stub）接收到消息，并进行解码（反序列化）；

9、服务消费方得到最终结果；

## RPC和SOA、SOAP、REST的区别

**1、REST**

可以看着是**HTTP协议的一种直接应用**，默认**基于JSON作为传输格**式,使用简单,学习成本低效率高,但是安全性较低。：springboot Cloud

**2、SOAP**

**SOAP是一种数据交换协议规范,**是一种轻量的、简单的、基于XML的协议的规范。而SOAP可以看着是一个重量级的协议，基于XML、SOAP在安全方面是通过使用XML-Security和XML-Signature两个规范组成了WS-Security来实现安全控制的,当前已经得到了各个厂商的支持 。：Web Service

它有什么优点？简单总结为：易用、灵活、跨语言、跨平台。

**3、SOA**

面向服务架构，它可以根据需求**通过网络对松散耦合的粗粒度应用组件进行分布式部署**、组合和使用。服务层是SOA的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。

SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型。SOA可以看作是B/S模型、XML（标准通用标记语言的子集）/Web Service技术之后的自然延伸。 dubbo

**4、REST 和 SOAP、RPC 有何区别呢?**

没什么太大区别，他们的本质都是提供可支持分布式的基础服务，最大的区别在于他们各自的的特点所带来的不同应用场景 。

## RPC框架需要解决的问题？

1、如何确定客户端和服务端之间的**通信协议**？ tcp

2、如何更高效地进行**网络通信**？netty

3、服务端提供的**服务如何暴露**给客户端？zookeeper

4、客户端如何**发现这些暴露的服务**？watch

5、如何更高效地对请求对象和响应结果进行**序列化和反序列化操作**？ hession java原声

## RPC的实现基础？

1、需要有非常高效的网络通信，比如一般选择**Netty**作为网络通信框架；

2、需要有比较**高效的序列化**框架，比如谷歌的Protobuf序列化框架；

3、可靠的寻址方式（主要是**提供服务的发现**），比如可以使用Zookeeper来注册服务等等；

4、如果是带会话（状态）的RPC调用，还需要有会话和**状态保持**的功能；

## RPC使用了哪些关键技术？

**1、动态代理**

**生成Client Stub（客户端存根）和Server Stub（服务端存根）的时候需要用到Java动态代理技术**，可以使用JDK提供的原生的动态代理机制，也可以使用开源的：CGLib代理，Javassist字节码生成技术。

**2、序列化和反序列化**

在网络中，所有的数据都将会被转化为字节进行传送，所以为了能够使参数对象在网络中进行传输，需要对这些参数进行序列化和反序列化操作。

- 序列化：把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。
- 反序列化：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。

目前比较高效的开源序列化框架：如Kryo、**FastJson**和Protobuf等。

**3、NIO通信**

出于并发性能的考虑，传统的阻塞式 IO 显然不太合适，因此我们需要异步的 IO，即 NIO。Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的 NIO.2 支持。可以**选择Netty或者MINA来解决NIO数据传输**的问题。

**4、服务注册中心**

可选：Redis、Zookeeper、Consul 、Etcd。一般使用ZooKeeper提供服务注册与发现功能，解决单点故障以及分布式部署的问题(注册中心)。



## RPC框架需要解决的问题Dubbo的解决？

1、如何确定客户端和服务端之间的**通信协议**？

dubbo 提供 dubbo、rmi、webservice、http、hessian、memcache、redis

2、如何更高效地进行**网络通信**？

netty

3、服务端提供的**服务如何暴露**给客户端？

zookeeper、redis

4、客户端如何**发现这些暴露的服务**？

zookeeper

5、如何更高效地对请求对象和响应结果进行**序列化和反序列化操作**？

hession、java序列化

## Dubbo 的协议

**dubbo****：** 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步，Hessian 序列化；

 **rmi****：** 采用 JDK 标准的 rmi 协议实现，传输参数和返回参数对象需要实现Serializable 接口，使用 java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。多个短连接，TCP 协议传输，同步传输，适用常规的远程服务调用和 rmi 互操作。在依赖低版本的 Common-Collections 包，java 序列化存在安全洞；

 **webservice****：** 基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用；

 **http****：** 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用；

**hessian****：** 集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件；

**memcache**： 基于 memcached 实现的 RPC 协议

 **redis**：基于 redis 实现的 RPC 协议

### dubbo 负载均衡

**Random LoadBalance:** 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀；

**RoundRobin LoadBalance:** 轮循选取提供者策略，平均分布，但是存在请求累积的问题；

**LeastActive LoadBalance:** 最少活跃调用策略，解决慢提供者接收更少的请求；

**ConstantHash LoadBalance:** 一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动；


![image-20201214182118777](/Users/yangyibo/Library/Application Support/typora-user-images/image-20201214182118777.png)




## 步骤

**1、建立通信**

首先要解决通讯的问题：即A机器想要调用B机器，首先得建立起通信连接。

主要是通过在客户端和服务器**之间建立TCP连接**，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，**调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接**。

通常这个连接可以是按需连接（需要调用的时候就先建立连接，调用结束后就立马断掉），也可以是长连接（客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效），多个远程过程调用共享同一个连接。

**2、服务寻址**

要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么。

通常情况下我们需要提供B机器（主机名或IP地址）以及特定的端口，然后指定调用的方法或者函数的名称以及入参出参等信息，这样才能完成服务的一个调用。

可靠的寻址方式（主要是提供服务的发现）是RPC的实现基石，比如可以采用Redis或者Zookeeper来注册服务等等。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190322171840620.png)

**2.1、从服务提供者的角度看：**

当服务提供者启动的时候，需要将自己提供的服务注册到指定的注册中心，以便服务消费者能够通过服务注册中心进行查找；

当服务提供者由于各种原因致使提供的服务停止时，需要向注册中心注销停止的服务；

服务的提供者需要定期向服务注册中心发送心跳检测，服务注册中心如果一段时间未收到来自服务提供者的心跳后，认为该服务提供者已经停止服务，则将该服务从注册中心上去掉。

**2.2、从调用者的角度看：**

服务的调用者启动的时候根据自己订阅的服务向服务注册中心查找服务提供者的地址等信息；

当服务调用者消费的服务上线或者下线的时候，注册中心会告知该服务的调用者；

服务调用者下线的时候，则取消订阅。

**3、网络传输**

**3.1、序列化**

当A机器上的应用发起一个RPC调用时，调用方法和其入参等信息需要通过底层的网络协议如TCP传输到B机器，由于网络协议是基于二进制的，所有我们传输的参数数据都需要先进行序列化（Serialize）或者编组（marshal）成二进制的形式才能在网络中进行传输。然后通过寻址操作和网络传输将序列化或者编组之后的二进制数据发送给B机器。

**3.2、反序列化**

当B机器接收到A机器的应用发来的请求之后，又需要对接收到的参数等信息进行反序列化操作（序列化的逆操作），即将二进制信息恢复为内存中的表达方式，然后再找到对应的方法（寻址的一部分）进行本地调用（一般是通过生成代理Proxy去调用,
通常会有JDK动态代理、CGLIB动态代理、Javassist生成字节码技术等），之后得到调用的返回值。

**4、服务调用**

B机器进行本地调用（通过代理Proxy和反射调用）之后得到了返回值，此时还需要再把返回值发送回A机器，同样也需要经过序列化操作，然后再经过网络传输将二进制数据发送回A机器，而当A机器接收到这些返回值之后，则再次进行反序列化操作，恢复为内存中的表达方式，最后再交给A机器上的应用进行相关处理（一般是业务逻辑处理操作）。

通常，经过以上四个步骤之后，一次完整的RPC调用算是完成了，另外可能因为网络抖动等原因需要重试等。

## 优缺点

RPC框架的好处就显示出来了，**首先就是长链接**，不必每次通信都要像http一样去3次握手什么的，减少了网络开销；

其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。

RPC服务和HTTP服务还是存在很多的不同点的，一般来说，RPC服务主要是针对大型企业的，而HTTP服务主要是针对小企业的，因为RPC效率更高，而HTTP服务开发迭代会更快。



[看了这篇Dubbo RPC面试题，让天下没有难面的面试题][https://blog.csdn.net/xlgen157387/article/details/88746098]


