# jvm 的堆、栈、方法区

https://www.cnblogs.com/andy-zhou/p/5327288.html
https://www.cnblogs.com/woshimrf/p/jvm-garbage.html
https://blog.csdn.net/qq_31337311/article/details/78799262
https://blog.csdn.net/u012998254/article/details/81428621



**内存泄露**：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。

**内存溢出**：申请的内存超出了JVM能提供的内存大小，此时称之为溢出。

最常见的OOM情况有以下三种：

- java.lang.OutOfMemoryError: Java heap space ------>java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。
- java.lang.OutOfMemoryError: PermGen space ------>java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。
- java.lang.StackOverflowError ------> 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。

## 分析

**OOM分析--heapdump**

https://www.jianshu.com/p/0744abda44cb

###0、栈是运行时单位，而堆是存储的单位。

栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。

在Java中一个线程就会相应有一个线程栈与之对应，这点很容易理解，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等；而堆只负责存储对象信息。

### 1、java中的栈（stack）和堆（heap）是java在内存（ram）中存放数据的地方

* （1）当程序运行时，首先通过类装载器加载字节码文件，经过解析后装入方法区！在方法区中存了类的各种信息，包括类变量、常量及方法。对于同一个方法的调用，同一个类的不同实例调用的都是存在方法区的同一个方法。类变量的生命周期从程序开始运行时创建，到程序终止运行时结束！ 
* （2）当程序中new一个对象时，这个对象存在堆中，对象的变量存在栈中，指向堆中的引用！对象的成员变量都存在堆中，当对象被回收时，对象的成员变量随之消失！ 
* （3）当方法调用时，JVM会在栈中分配一个栈桢，存储方法的局部变量。当方法调用结束时，局部变量消失！

###2、堆中存什么？栈中存什么？

堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。一个对象的大小是不可估计的，或者说是可以动态变化的，但是在栈中，一个对象只对应了一个4btye的引用（堆栈分离的好处：））。

为什么不把基本类型放堆中呢？因为其占用的空间一般是1~8个字节——需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的（还会浪费空间，后面说明）。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据。最常见的一个问题就是，Java中参数传递时的问题。

对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。

### 3、堆区  对象、成员变量

* 存储的全部是对象，每个对象都包含一个与之对应的class的信息.（class的目的是得到操作指令）；
* jvm只有一个heap区，被所有**线程共享**，不存放基本类型和对象引用，只存放对象本身。
* **堆的优劣势**：堆的优势是可以动态的分配内存大小，生存期也不必事先告诉编译器，java的垃圾收集器会自动收取这些不在使用的数据，但缺点是，由于要在运行时动态分配内存，存取速度慢。

### 3、栈区 局部变量 

* 每一个线程包含一个stack区，只保存**基本数据类型的对象和自定义对象的引用（不是对象**），对象都存放在共享heap中；每个栈中的数据（基本数据类型和对象引用）都是私有的，其他栈不能访问；栈分为3部分：基**本类型变量区**、**执行环境上下文**、操作指令区（存放操作指令）
* 栈的优势劣势：**存取速度比堆要快**，仅次于直接位于CPU的寄存器，但**必须确定的是存在stack中的数据大小与生存期**必须是确定的，**缺乏灵活性**。
* 单个stack的数据可以共享。在java中，所有基本类型和引用类型都在stack中储存，栈中数据的生存空间一般在当前scopes内

####方法区（Method Area）

方法区（Method Area）：与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。很多人都更愿意把方法区称为“永久代”（Permanent Generation）。从jdk1.7已经开始准备“去永久代”的规划，jdk1.7的HotSpot中，已经把**原本放在方法区中的静态变量、字符串常量池等移到堆内存**中。

**在jdk1.8中，永久代已经不存在，存储的类信息、编译后的代码数据等已经移动到了元空间**（MetaSpace）中，元空间并没有处于堆内存上，而是直接占用的本地内存（NativeMemory）

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小

### 4、方法区 类信息、类变量（静态变量和常量）、方法

* 1、方法区又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量；
* 2、方法区中包含的都是在程序中永远的唯一的元素

* 常量池 (放在方法区)
  * Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。
  * 所谓静态常量池，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。
  * 而运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池
  * 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。
  * 栈：在Java中，JVM中的栈记录了线程的方法调用。每个线程拥有一个栈。在某个线程的运行过程中，如果有新的方法调用，那么该线程对应的栈就会增加一个存储单元，即帧(frame)。在frame中，保存有该方法调用的参数、局部变量和返回地址。
  * 堆：是JVM中一块可自由分配给对象的区域。当我们谈论垃圾回收(garbage collection)时，我们主要回收堆(heap)的空间。
    Java的普通对象存活在堆中。与栈不同，堆的空间不会随着方法调用结束而清空。因此，在某个方法中创建的对象，可以在方法调用结束之后，继续存在于堆中。这带来的一个问题是，如果我们不断的创建新的对象，内存空间将最终消耗殆尽。

##GC

新生代由于其对象存活时间短，且需要经常gc，因此采用效率较高的复制算法，其将内存区分为一个eden区和两个suvivor区，eden区和survivor区的比例是8:1，分配内存时先分配eden区，当eden区满时，使用**复制算法**进行gc，将存活对象复制到一个survivor区，当一个survivor区满时，将其存活对象复制到另一个区中，当对象存活时间大于某一阈值时，将其放入老年代。 
老年代和永久代因为其存活对象时间长，因此使用**标记清除或标记整理算法**



## 按照基本回收策略分

* 引用计数（Reference Counting）:

比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。**此算法最致命的是无法处理循环引用的问题**。

* 标记-清除（Mark-Sweep）:
  此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。**此算法需要暂停整个应用，同时，会产生内存碎片**。

* 复制（Copying）:

此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，**遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。**次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此**算法的缺点也是很明显的，就是需要两倍内存空间**。

**商业虚拟机用这个回收算法来回收新生代**

* 标记-整理（Mark-Compact）:

此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。

**老年代标记-清理“和”标记-整理“算法来进行回收。**

##Java中可以作为GC Root的对象有

* 虚拟机栈中引用的对象（本地变量表）
* 方法区中静态属性的引用对象
* 方法区中常量引用对象
* 本地方法栈中引用对象（Native 对象）
* 主要执行在上下文中和全局性的引用

#分区对待的方式分

* 增量收集（Incremental Collecting）:
  实时垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么原因JDK5.0中的收集器没有使用这种算法的。

* 分代收集（Generational Collecting）:
  基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青代、年老代、持久代，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的。

#为什么要分代

分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。

#什么情况下触发垃圾回收

由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。jdk1.8 后分为 Minor GC、Major GC和Full GC，清理Eden区和 Survivor区叫Minor GC。清理Old区叫Major GC。清理整个堆空间—包括年轻代和老年代叫Full GC。

##Scavenge GC

一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。

##Full GC

对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：

* 年老代（Tenured）被写满
* 持久代（Perm）被写满 
* System.gc()被显示调用 
* 上一次GC之后Heap的各域分配策略动态变化

##GC

新生代由于其对象存活时间短，且需要经常gc，因此采用效率较高的复制算法，其将内存区分为一个eden区和两个suvivor区，eden区和survivor区的比例是8:1，分配内存时先分配eden区，当eden区满时，使用**复制算法**进行gc，将存活对象复制到一个survivor区，当一个survivor区满时，将其存活对象复制到另一个区中，当对象存活时间大于某一阈值时，将其放入老年代。 
老年代和永久代因为其存活对象时间长，因此使用**标记清除或标记整理算法**


# 垃圾回收的瓶颈

传统分代垃圾回收方式，已经在一定程度上把垃圾回收给应用带来的负担降到了最小，把应用的吞吐量推到了一个极限。但是他无法解决的一个问题，就是Full GC所带来的应用暂停。在一些对实时性要求很高的应用场景下，GC暂停所带来的请求堆积和请求失败是无法接受的。这类应用可能要求请求的返回时间在几百甚至几十毫秒以内，如果分代垃圾回收方式要达到这个指标，只能把最大堆的设置限制在一个相对较小范围内，但是这样有限制了应用本身的处理能力，同样也是不可接收的。

分代垃圾回收方式确实也考虑了实时性要求而提供了并发回收器，支持最大暂停时间的设置，但是受限于分代垃圾回收的内存划分模型，其效果也不是很理想。

为了达到实时性的要求（其实Java语言最初的设计也是在嵌入式系统上的），一种新垃圾回收方式呼之欲出，它既支持短的暂停时间，又支持大的内存空间分配。可以很好的解决传统分代方式带来的问题。



## G1

G1垃圾回收器中。标记-复制算法可以分为三个阶段：

- **标记阶段**，即从GC Roots集合开始，标记活跃对象；
- **转移阶段**，即把活跃对象复制到新的内存地址上；
- **重定位阶段**，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。

**1.标记阶段停顿分析**

**初始标记阶段**：初始标记阶段是指从GC Roots出发标记全部直接子节点的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。

**并发标记阶段**：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。

**再标记阶段：**重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。

**2.清理阶段停顿分析**



清理阶段清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的。



**3.复制阶段停顿分析**



复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。



四个STW过程中，初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。因此，G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW。为什么转移阶段不能和标记阶段一样并发执行呢？主要是G1未能解决转移过程中准确定位对象地址的问题。



G1的Young GC和CMS的Young GC，其标记-复制全过程STW，这里不再详细阐述。

## ZGC

The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器，它的**设计目标**包括：

- 停顿时间不超过10ms；
- 停顿时间不会随着堆的大小，或者活跃对象的大小而增加；
- 支持8MB~4TB级别的堆（未来支持16TB）。

从设计目标来看，我们知道ZGC适用于大内存低延迟服务的内存管理和回收。

ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。

### ZGC关键技术

ZGC通过**着色指针**和**读屏障**技术**，解决了转移过程中准确访问对象的问题，实现了并发转移**。**大致原理描述如下**：并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在ZGC中，**应用线程访问对象将触发“读屏障”**，如果发现对象被移动了，那么**“读屏障”会把读出来的指针更新到对象的新地址上**，这样应用线程始终访问的都是对象的新地址。那么，**JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针**。

## 着色指针

**着色指针是一种将信息存储在指针中的技术**。**ZGC仅支持64位系统，它把64位虚拟地址空间划分为多个子空间**，如下图所示：

CPU的位是指一次性可处理的数据量是多少，1字节=8位，32位处理器可以一次性处理4个字节的数据量，64位处理器一次性可以处理64个字节。

32位和64位处理器还涉及到内存的寻址方面，32位系统的处理器最大只支持到4G内存，而64位系统最大支持的内存高达亿位数。 这也是如今人们纷纷淘汰32位系统的主要原因



读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅“从堆中读取对象引用”才会触发这段代码。

读屏障示例：

```Java
Object o = obj.FieldA   // 从堆中读取引用，需要加入屏障
<Load barrier>
Object p = o  // 无需加入屏障，因为不是从堆中读取引用
o.dosomething() // 无需加入屏障，因为不是从堆中读取引用
int i =  obj.FieldB  //无需加入屏障，因为不是对象引用
```

接下来详细介绍ZGC一次垃圾回收周期中地址视图的切换过程：

- **初始化**：ZGC初始化之后，**整个内存空间的地址视图被设置为Remapped**。程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入标记阶段。
- **并发标记阶段**：第一次进入标记阶段时**视图为M0**，如果**对象被GC标记线程或者应用线程访问过**，那么就将对象的**地址视图从Remapped调整为M0**。所以，在标记阶段结束之后，对象的地址要么是M0视图，要么是Remapped。如**果对象的地址是M0视图，那么说明对象是活跃的**；如果对象的地址是Remapped视图，说明对象是不活跃的。
- **并发转移阶段**：标记结束后就进入转移阶段，此时地址视图再次被设置为Remapped。如果**对象被GC转移线程或者应用线程访问过，那么就将对象的地址视图从M0调整为Remapped**。

其实，在标记阶段存在**两个地址视图M0和M1**，上面的过程显示只用了一个地址视图。之所以设计成两个，是为了**区别前一次标记和当前标记**。也即，**第二次进入并发标记阶段后，地址视图调整为M1**，而非M0。

**着色指针**和**读屏障**技术**不仅应用在并发转移阶段，还应用在并发标记阶段：将对象设置为已标记**，**传统的垃圾回收器需要进行一次内存访问，并将对象存活信息放在对象头中**；而在ZGC中，**只需要设置指针地址的第42~45位即可，并且因为是寄存器访问，所以速度比访问内存更快**。





ZGC（The Z Garbage Collector）

**关键技术：**着色指针、读屏障

**算法：标记-复制算法**（重大改进，ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因）

**过程：**

ZGC只有三个STW阶段：**初始标记**，**再标记**，**初始转移**。其中，初始标记和初始转移分别都只需要扫描所有GC Roots，其处理时间和GC Roots的数量成正比，一般情况耗时非常短；

**再标记阶段STW时间很短**，最多1ms，超过1ms则再次进入**并发标记阶段**（通过着色指针技术，准确访问对象，做到并发转移）。即，**ZGC几乎所有暂停都只依赖于GC Roots集合大小**，**停顿时间不会随着堆的大小或者活跃对象的大小而增加**。与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。

**关键技术：**

ZGC通过**着色指针**和**读屏障**技术，解决了**转移过程中准确访问对象的问题，实现了并发转移**。大致原理描述如下：并发转移中“并发”意味着**GC线程在转移对象的过程中，应用线程也在不停地访问对象**。**假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址**。那么，JVM是通过**对象引用的地址，即着色指针**，判断对象是否被移动。

**优点：**

- 停顿时间不超过10ms；
- 停顿时间不会随着堆的大小，或者活跃对象的大小而增加；
- 支持8MB~4TB级别的堆（未来支持16TB）。




字节码

魔法类

hashmap









.class 字节码文件 2进制

java -p  字节码到类似汇编

### 类加载原理

Java 语言是一种具有动态性的解释型语言，类（Class）只有被加载到 JVM 后才能运行。当运行指定程序时，JVM 会将编译生成的 .class 文件按照需求和一定的规则加载到内存中，并组织成为一个完整的 Java 应用程序。这个加载过程是由类加载器完成，具体来说，就是由 ClassLoader 和它的子类来实现的。类加载器本身也是一个类，其实质是把类文件从硬盘读取到内存中。类的加载方式分为隐式加载和显示加载。隐式加载指的是程序在使用 new 等方式创建对象时，会隐式地调用类的加载器把对应的类加载到 JVM 中。显示加载指的是通过直接调用 class.forName() 方法来把所需的类加载到 JVM 中。

任何一个工程项目都是由许多类组成的，当程序启动时，只把需要的类加载到 JVM 中，其他类只有被使用到的时候才会被加载，采用这种方法一方面可以加快加载速度，另一方面可以节约程序运行时对内存的开销。此外，在 Java 语言中，每个类或接口都对应一个 .class 文件，这些文件可以被看成是一个个可以被动态加载的单元，因此当只有部分类被修改时，只需要重新编译变化的类即可，而不需要重新编译所有文件，因此加快了编译速度。

在 Java 语言中，类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类（例如基类）完全加载到 JVM 中，至于其他类，则在需要的时候才加载。

类加载的主要步骤：

* 装载。根据查找路径找到相应的 class 文件，然后导入。
* 链接。链接又可分为 3 个小步：
* 检查，检查待加载的 class 文件的正确性。
* 准备，给类中的静态变量分配存储空间。
* 解析，将符号引用转换为直接引用（这一步可选）
*  初始化。对静态变量和静态代码块执行初始化工作。

# 类加载

加载：根据查找路径找到相应的 class 文件，将class转化成二进制流。将二进制流中的静态存储结构化方法转还为**方法区运行时数据结构**。在**堆内存**中生成该类的JAVA.lang.Class 对象，作为该类的数据访问入口。（这里只是一个引用，并不是把类放入堆中）使用类加载，类加载器有四个 启动类加载器(Bootstrap ClassLoader)、扩展类加载器(extensions class loader)、Apps（系统）类加载器（system class loader）、用户自定义类加载器。遵循双亲委派，当然也有例外：如tomcat 和 spi

验证：检查待加载的 class 文件格式的正确性 ，为了确保class文件字节流中的信息不会危害到虚拟机

准备：在方法区中为**静态变量分配内存**，并将其初**始化为默认值（此时默认值皆为空，在初始化阶段赋值）**准备阶段不分配类中的实例变量内存。实例变量将会在对象实例化时随着对象分配在Java堆中。

解析：将符号引用转化为值引用。因为准备阶段已经分配内存了，所以这一步是将 符号引用转换为 对内存地址的直接引用了。

初始化：对**静态变量和静态代码块执行初始化工作**。也就是为静态变量赋值。

使用

卸载

实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。

主要有一下四种类加载器:

1. 启动类加载器(Bootstrap ClassLoader)用来加载 java 核心类库，无法被 java 程序直接引用。
2. 扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
3. 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。
4. 用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。



## 加载：

在被JVM加载的时候，JVM会给这个类创建一个`instanceKlass`，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个`instanceOopDesc`对象，这个对象中包含了对象头以及实例数据，保存在堆内存中。



堆指向方法区

栈 指向 堆   Object obj = new Object    obj存在程序栈的局部变量中。  new Object 存在堆中

常量指向堆 static  Object obj = new Object   obj存在常量池中。  new Object 存在堆中

jvm 调优

 nohup java -Xms512m -Xmx1024m -XX:PermSize=256m -XX:MaxPermSize=512m -jar /src/middle-order-timing-provider/middle-order-timing-provider-1.0.0.jar &>/dev/null &



https://blog.csdn.net/LiushaoMr/article/details/105171434

-XX:MaxPermSize=512m  **老生代对象能占用内存的最大值**

-XX:PermSize=256m  设置持久代(perm gen)初始值



https://www.cnblogs.com/grey-wolf/p/9217497.html





## **指令重排**

还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是**处理器优化**。

除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做**指令重排**。

### 并发编程

并发编程的问题你应该有所了解，比如**原子性**问题，**可见性**问题和**有序性**问题。

**原子性**是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。

**可见性**是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

**有序性**即程序执行的顺序按照代码的先后顺序执行。

**缓存一致性问题**其实就是**可见性问题**。而**处理器优化**是可以导致**原子性问题**的。**指令重排**即会导致**有序性问题**。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。

### 内存模型

为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。**为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。**通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。

### Java内存模型

**Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。**

**，JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。**

**Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。**

### 原子性

在Java中，为了保证原子性，提供了两个高级的字节码指令`monitorenter`和`monitorexit`。在[synchronized的实现原理](http://47.103.216.138/archives/1883)文章中，介绍过，这两个字节码，在Java中对应的关键字就是`synchronized`。

因此，在Java中可以使用`synchronized`来保证方法和代码块内的操作是原子性的。

### 可见性

Java内存模型是通过在变量修改后将新值同步回主内存，在**变量读取前从主内存刷新变量值**的这种依赖主内存作为传递媒介的方式来实现的。

Java中的`volatile`关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用`volatile`来保证多线程操作时变量的可见性。

除了`volatile`，Java中的`synchronized`和`final`两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。

### 有序性

在Java中，可以使用`synchronized`和`volatile`来保证多线程之间操作的有序性。实现方式有所区别：

`volatile`关键字会禁止指令重排。`synchronized`关键字保证同一时刻只允许一条线程操作。

参考：再有人问你Java内存模型是什么，就把这篇文章发给他。： https://www.hollischuang.com/archives/2550?spm=a2c6h.12873639.0.0.48a823a8hAhG6F













方法区也称为非堆，逻辑堆，持久代，永久代 full GC

![image-20201028200506610](/Users/yangyibo/Library/Application Support/typora-user-images/image-20201028200506610.png)

根据对象的生命周期，分为老年 和新生代。避免有些长期存在的对象 频繁被cg 扫描

扫描次数 。15 ，2位 的二进制，最大 15 。默认15 ，可以修改



内存空间不连续，内存碎片，整块大对象放不下。导致空间不可用

永远保留一份 s 区的空间是干净的，用来腾挪对象，解决内存碎片问题，保证空间连续。浪费了一个块内存，保证了空间的连续性



eden 分配新对象。其中一个s区保存 存活对象。  另外一个s 为空。

eden 越小 GC 越多。

堆内存，担保机制，当有新的很大的 对象产生，eden 放不下区时，会直接放入old。old 区 一般会为 eden 的2倍。

![image-20201028203333803](/Users/yangyibo/Library/Application Support/typora-user-images/image-20201028203333803.png)



![image-20201028203641350](/Users/yangyibo/Library/Application Support/typora-user-images/image-20201028203641350.png)

perm space 使用jvm 内存

meta Space 使用 native内存，使用本地内存。

MetaSpace 防止 的改进是 为了防止程序类太多，程序启动便 内存溢出了。

Major GC 和 MetaSpace 绑定，任何一个触发都话导致其他的触发，并触发full GC

minor GC 满了会导致 Major GC 然后导致 MetaSpace GC 然后 full GC

jvisualvm 监控

outofmemoryError  ：方法区和 堆 内存不足

内存泄漏 和 内存溢出 GC 太多

栈压满 ：栈深度大概默认7000，调用7000个方法       参数： -XSs 设置栈内存空间 

回收哪一块区域？堆。线程不用回收，因为生命周期短

method Area，生命周期太长，所以回收的都是堆。



如何判断垃圾：



可达性：

根 ：GC Roots 对象



jni ： java native interface







GC 需要所有的线程停止（STW，stop the world），开始从 gc root 开始进行对象标记

为什么要停止STW？

该回收的没回收

不该回收的回收了



GC 重点

* 精准 高效收集垃圾

* 垃圾收集器

算法



#### 标记-清除

 递归，效率低下，SWT

内存不连续，空间碎片

#### 复制（新生代）

复制，把存活的对象，复制到新的区域

浪费一半内存，死得快，不需要太大的空间，但是需要效率快。空间换时间

#### 标记整理

效率慢最慢，遍历完成后进行整理。

#### 分治算法



我们的垃圾回收流程。

1.回收那部分内存？

根据Java 的内存结构我们知道，jvm 分为 方法区、堆、程序计数器、本地方法栈、jvm虚拟方法栈。由于程序计数器、本地方法栈、jvm虚拟方法栈，是由线程而生，随线程而灭，生命周期比较短。所以其中的对象我们不要关心回收。

方法区中存储的是 类的相关信息及常量、静态变量、字符串等，生命周期比较长，所以也不是我们垃圾回收主要关心的对象。所以我们主要关心的是堆内存中的对象。

2.如果确定对象为垃圾？

确认堆内存中的对象为垃圾主要有两种算法：是引用计数法和可达性分析法（又名根搜索法）

（1）引用计数法：简单来说就是给对象添加一个引用计数器，每当对象被引用一次就加1，引用失效时就减1。当为0的时候就判断对象不会再被引用。

优点：是实现简单效率高，被应用在python中。

缺点：无法解决对象间循环引用问题。导致循环引用的对象无法被回收。

（2）可达性分析法（又名根搜索法）：基本思路是通过一个称为“GC Roots”的对象为起始点，搜索所经过的路径称为引用链，当一个对象到 GC Roots 没有任何引用 跟它连接 则证明对象是不可用的。即需要被回收。

可以作为GC Root的元素有四种：

 a.虚拟机栈(栈桢中的局部变量表)中的对象引用

b.方法区中的类静态属性引用的对象

c.方法区中的常量引用的对象

d.本地方法栈中JNI（native方法)引用的对象

名词解释：SWT （stop the word）

​	正常情况下，在执行可达性分析方法时，需要所有的线程停止。因为可达性分析需要从栈中的对象开始分析引用，如果不停止所有的线程，则会对象的引用会不停的变化。导致该回收的没回收，不该回收的回收了。

3. 垃圾回收机制

   jvm 使用分代垃圾回收的机制。根据对象的生命周期分为，年轻代、老年代、永久代（方法区）。根据分代回收的理念，将堆内存划分为 young 区和 old区，对应存放年轻代对象和 老年代对象。young 区又分为 eden 区和两个 survivor区，from survivor  和 to survivor 。eden 区和 两个 survivor区的内存默认比例为 8:1:1


4. GC 类别

   年轻代 GC称为 Minor GC/Young GC 

   老年代 GC称为 Major GC/Old GC

   永久代 GC称为 MetaSpace GC

   Full GC  = Minor GC + Major GC + MetaSpace GC
   
4. 回收垃圾的方法

   （1）复制算法：复制算法需要大小相同的两块内存区域，用空间换时间的思想实现。算法效率高，速度快。缺点是浪费一半内存。是先复制存活对象再回收垃圾。算法执行期间会 STW（stop the word）

   具体做法：根据可达性分析把存活的对象，复制到新的区域，然后直接干掉之前区域。

   应用：

   复制算法主要用在 年轻代的垃圾回收。创建新对象时会保存在eden区，当eden区满了之后，会触发minor GC，将存活的对象放入 from survivor 区，然后清空eden区。当eden 区域内存再次满了之后，会再次出发minor GC，此时会将 eden 中存活的对象和  from survivor 中存活的对象放入 to survivor  区域，然后清空 eden 和from survivor 区。之后eden 区域再次存储新的对象。内存中对象每经历一次GC 会在对象头的年龄位置+1，当对象经历minorGC 的次数为15次时，会放入old区。 （默认为15次，可以调整。因为对象头中年龄 占 4bit，二进制取值范围为 0-15）。

   

   担保机制：当有大对象产生时，eden区放不下，会借用old的空间存放。old 区 一般会为 eden 的2倍。

   
   
   分析：因为年轻代中的对象特点是 生命周期短，数量量大，所以GC 会比较频繁，但占用空间小。所以很适合用 复制算法。复制算法效率高，但是会浪费一半内存。			
   
   
   
   （2）标记清除：
   
   标记清理算法主要用在老年代的收集。此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，递归第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用（STW），同时，会产生内存碎片。
   
   （3）标记整理：
   
   标记整理算法主要用在老年代的收集。因为老年代存储的对象比年轻代多得多，而且不乏大对象。所以用复制算法效率低，且浪费空间。标记整理具体做法是，从根节点开始标记所有被引用对象，然后遍历整个堆，清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。





