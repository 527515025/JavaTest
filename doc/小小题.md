小小题：

**1. System.gc() 和 Runtime.gc() 会做什么事情？**

这两个方法用来提示 JVM 要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于 JVM 的。

 System.gc()  触发的是 full gc

**2. Java 中会存在内存泄漏吗，请简单描述。**
所谓**内存泄露**就是指一个**不再被程序使用的对象或变量一直被占**
**据在内存中**。

Java 中的内存泄露的情况：**长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露**，**尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收**。

通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的。

 **3. finalize() 方法什么时候被调用？析构函数 (finalization) 的目的是什么？**

垃圾回收器（garbage colector）决定回收某对象时，就会运行该对象的 finalize() 方法 但是在 Java 中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说 filalize() 可能永远不被执行，显然指望它做收尾工作是靠不住的。 finalize() 最主要的用途是回收特殊渠道申请的内存。Java 程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种 JNI（Java Native Interface）调用non-Java 程序（C 或 C++）， finalize() 的工作就是回收这部分的内存

**4.类加载器双亲委派模型机制？**
当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类
去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。

1. hashmap 为什么不安全

2. 一致性hash算法

3. 索引哪些情况会失效

4. 走索引仍然慢？ SQL很复杂，优化SQL结构，表数据量太大，索引过滤性不好，加载了不必要的字段/数据




## 1. 在100G文件8G内存中找出出现次数最多的100个IP?

思路：分治思想+排序

1. 由于100G文件加载不到内存，所以需要分治
2. 100G文件按照每5G一个文件拆分为20个文件，拆分文件时通过判断IP的A、B、C、段进行拆分，**尽量拆分平均，且相同IP拆分在同一文件中**，。当然也可以按照 IP转 long型，hash 分文件。（分表思想）
3. 分别计算每个文件中IP的出现次数。对单个文件进行计数统计，此步可以使用hashmap计数。
4. 使用堆排序计算出每个文件中取最多次的100IP
5. 合并所有文件计算出的100IP进行合并，再进行堆排序获取最多次100IP

为什么使用堆排序？

因为堆排序在处理找Top 问题上基于二分查找，复杂度时O(NlogK) ，而快排是 O(N)。

## 2. 100G大文件单机处理找到第一个不重复的字符串，16G内存限制

首先，不重复则说明需要遍历全文件，其次要记录每个字符串在原文件中第一次出现的位置

思路分治：

1. 将大文件切分成多个小文件。
2. 文件大小**尽量均匀**达到我们设置的内存，最重要的一点是**保证相同字符串要在同一个文件中**，用到Hash函数，相同字符串的hash函数值是相同的。存在极特殊情况某一段字符串很多，使得小文件分布不均匀，则遍历文件对一次分割文件变大的文件按照所占内存大小重新分割。
3. 切分文件时，每份文件中要记录每行的字符串内容以及在源文件中第一次出现的位置，用long型来存储
4. 读小文件把其存到内存中，分别计算每个文件中的**每个字符串其出现频率和第一次出现的位置**。每个文件**保存一个结果**，即**频率为1且最早出现的字符串信息**，以后遍历的每个文件中若有频率为1且更早索引位置的，将原有结果替换。最后返回第一个不重复的字符串。
5. 关于第 4步的字符串出现频率统计可用：
   * 维护一张hashmap在读取的时候统计词频，在内存范围内，统计词频，最后遍历只出现一次的字符串然后用堆排序选出该文件出现最早的字符串













































