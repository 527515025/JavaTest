##小小题：

**1. System.gc() 和 Runtime.gc() 会做什么事情？**

这两个方法用来提示 JVM 要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于 JVM 的。

 System.gc()  触发的是 full gc

**2. Java 中会存在内存泄漏吗，请简单描述。**
所谓**内存泄露**就是指一个**不再被程序使用的对象或变量一直被占**
**据在内存中**。

Java 中的内存泄露的情况：**长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露**，**尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收**。

通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的。

 **3. finalize() 方法什么时候被调用？析构函数 (finalization) 的目的是什么？**

垃圾回收器（garbage colector）决定回收某对象时，就会运行该对象的 finalize() 方法 但是在 Java 中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说 filalize() 可能永远不被执行，显然指望它做收尾工作是靠不住的。 finalize() 最主要的用途是回收特殊渠道申请的内存。Java 程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种 JNI（Java Native Interface）调用non-Java 程序（C 或 C++）， finalize() 的工作就是回收这部分的内存

**4.类加载器双亲委派模型机制？**
当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类
去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。

1. hashmap 为什么不安全

2. 一致性hash算法

3. 索引哪些情况会失效

4. 走索引仍然慢？ SQL很复杂，优化SQL结构，表数据量太大，索引过滤性不好，加载了不必要的字段/数据




## 1. 在100G文件8G内存中找出出现次数最多的100个IP?

思路：分治思想+排序

1. 由于100G文件加载不到内存，所以需要分治
2. 100G文件按照每5G一个文件拆分为20个文件，拆分文件时通过判断IP的A、B、C、段进行拆分，**尽量拆分平均，且相同IP拆分在同一文件中**，。当然也可以按照 IP转 long型，hash 分文件。（分表思想）
3. 分别计算每个文件中IP的出现次数。对单个文件进行计数统计，此步可以使用hashmap计数。
4. 使用堆排序计算出每个文件中取最多次的100IP
5. 合并所有文件计算出的100IP进行合并，再进行堆排序获取最多次100IP

为什么使用堆排序？

因为堆排序在处理找Top 问题上基于二分查找，复杂度时O(NlogK) ，而快排是 O(N)。

## 2. 100G大文件单机处理找到第一个不重复的字符串，16G内存限制

首先，不重复则说明需要遍历全文件，其次要记录每个字符串在原文件中第一次出现的位置

思路分治：

1. 将大文件切分成多个小文件。
2. 文件大小**尽量均匀**达到我们设置的内存，最重要的一点是**保证相同字符串要在同一个文件中**，用到Hash函数，相同字符串的hash函数值是相同的。存在极特殊情况某一段字符串很多，使得小文件分布不均匀，则遍历文件对一次分割文件变大的文件按照所占内存大小重新分割。
3. 切分文件时，每份文件中要记录每行的字符串内容以及在源文件中第一次出现的位置，用long型来存储
4. 读小文件把其存到内存中，分别计算每个文件中的**每个字符串其出现频率和第一次出现的位置**。每个文件**保存一个结果**，即**频率为1且最早出现的字符串信息**，以后遍历的每个文件中若有频率为1且更早索引位置的，将原有结果替换。最后返回第一个不重复的字符串。
5. 关于第 4步的字符串出现频率统计可用：
   * 维护一张hashmap在读取的时候统计词频，在内存范围内，统计词频，最后遍历只出现一次的字符串然后用堆排序选出该文件出现最早的字符串

## 内存溢出+CPU占用过高:问题排查+解决方案+复盘

https://zhanghan.blog.csdn.net/article/details/109255980

- 排查内存溢出的思路
- 排查内存溢出过程中用到的命令及工具（Linux命令，[Eclipse Memory Anaylzer[MAT\]](https://www.eclipse.org/mat/)）
- 定位系统内存溢出的代码，并进行优化
- 此次内存溢出问题复盘

**问题：**

- 业务反馈程序用的十分卡，同时测试自己测的也十分卡
- 请求日志发现确实存在问题，线上是两台部署：两台机器上都是，一次请求耗时由原来的几毫秒变为10几秒
- CPU跑的过高，当时是4核，CPU持续飙到350%+；

临时解决方案：**重启**

- 当时为了减少对业务影响，直接将生产两台服务器上的项目进行重启
- 项目**启动参数中**没有加内存溢出日志输出（后续博客为大家介绍JVM调优时讲解启动命令中**加内存溢出日志输出**），重启后出问题时项目的JVM信息丢失了

复现问题方式：在开发环境对程序进行持续压测;压测相关服务器配置

**定位问题**

- **top命令**查看最耗CPU的进程（进程:17038;CPU持续飙到595%+）

- 查看**该进程中最耗CPU的线程**(发现有一些线程占用CPU较高)  
  ```shell
  top -Hp pid 
  ```

- 将线程号转为16进制,同时查看这些线程当前正在干什么（在此以17045线程为例）

  ```shell
  printf '%x\n' 17045
  # 17038为进程号,0x4295为最耗CPU线程的十六进制
  jstack 17038 | grep '0x4295' -C10 --color
  ```

* 可以看到**最耗CPU的线程都是在进行GC**

* 用Jmap命令查看当前堆的使用情况(发现老年代现在已占用99.8%+)
  ```shell
  jmap -heap 17038
  ``
  ```
```
  
* 查看gc频率的命令（其中O代表老年代占用率，FGC是FullGC次数，FGCT是fullGC时间；可以看出在频繁FullGC但是老年代有资源一直释放不掉）

  ```shell
  jstat -gcutil 17038 5000
```

* 通过**分析出问题时线上日志**发现内存溢出；至此定位到问题根源是内存溢出导致（有未释放资源堆积，导致老年代被占满，然后频繁的FullGC但是资源一直释放不了）

  ```shell
  grep -m 10 'OutOfMemoryError' *.log
  ```

* 分析问题产生原因

* 由于线上当时直接重启，未能保留当时的JVM内存文件；在**开发环境进行循环压测，复现线上问题**，然后**导出dump文件进行分析**找到原因。生成dump文件命令

  ```shell
  # 生成dump文件命令
  # 其中fileName是导出后dump名称,pid为进程号
  jmap -dump:format=b,file=fileName.dump pid
  
  ```
  
* 将dump文件导出到本地，用Eclipse Memary Analysis（MAT[官网下载地址](https://www.eclipse.org/mat/downloads.php)） 进行分析

  而在idea中也有这么一个插件，就是**JProfilerl**。  MAT导入dump文件,按对象排序视图进行查看。
  
* 分析内存占用类，查看代码为何释放不掉。然后进行代码优化

* 优化后再次进行验证，压测和dump 文件分析

### 预警：

- 程序预警：为减少业务影响，增加接口耗时的预警（后续博文为大家共享）；实现方式：
  \- 在每次程序处理完进行预警（比如本次请求>阈值）;缺点：消耗性能影响正常业务
  \- 在ELK清洗时用相关插件进行预警；优点：和业务解耦，对业务无影响
- 服务器预警：运维增加CPU内存，日志内存溢出监控

### 总结

1. 发现问题，重启大法。故障重现

2. jsp 或者 ps -ef | grep 命令查询 PID

3. top pid 查看cpu 情况

4. top -Hp pid  查看进程下有问题的 线程

5. 将线程号转为16进制，查看线程在干什么是否在GC或者其他的事情，然后在根据情况分析

   ```shell
   # 将线程号转为16进制  17045 为线程号
   printf '%x\n' 17045
   # 17038为进程号,0x4295为最耗CPU线程的十六进制
   jstack 17038 | grep '0x4295' -C10 --color
   ```

6. jmap -heap 17038 用Jmap命令查看当前堆的使用情况，看fullGC 后，老生代内存是否释放，youngGC 后 新生代GC后内存是否释放。**如果fullGC 后老生代内存 内存仍然很高**，此时dump 出线程日志，分析问题。看是需要增加内存还是内存溢出、泄漏

   ```shell
   # 生成dump文件命令
   # 其中fileName是导出后dump名称,pid为进程号
   jmap -dump:format=b,file=fileName.dump pid
   
   ```

7. 通过eclipse 的 MAT  或者idea 的 JProfilerl 插件进行dump 文件分析，分析有问题的类。分析代码，进行排查，优化。

   

## zookeeper 脑裂解决方案



## jdk1.8为什么把元空间放在堆外内存？

- 字符串存在永久代中，容易出现性能问题和内存溢出
- 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出
- 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低
- 官方解释，将 HotSpot 与 JRockit 合二为一，为了 融合rocket vm 废除的 永久代





## 一台服务器能支持多少连接，为什么

tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。

## socket有几个队列

两个，一个是 SYN queue半链接、和 accept queue 连接队列

建立socket连接的过程：
  1.client发syn请求给server 
  2.server收到后把请求存放在SYN queue里，这个半连接队列的最大值是系统参数               tcp_max_syn_backlog定义的
  3.存放在半连接队列后发送syn+ack给client，client收到后再发syn+ack给server完成三次握手，然后server把连接存放在accept queue ，这个队列长度就是程序里调用socket的时候定义的backlog定义大小。
  4.应用程序通过调用accept()到accept queue里获取连接。
  坑爹的特性来了！注意！
  当accept queue满了会怎么样？
  ！！注意！如果accept队列满了，linux会出现一个异常处理，去判断tcp_abort_on_overflow系统参数是否为1，如果为1 ，则会发出拒绝客户端的终止讯息并断开连接。但是如果这个参数是0，那就坑爹了！，对于溢出队列的连接，linux不会去管它，会继续正常建立连接，但是在accept queue里没有，那就意味着你的程序用accept()函数无法取的连接！这是多么的坑爹啊！！！根本查不出原因好么！！！各种被误导好么！！！尼玛linux啊！！



## 负载均衡器

**负载均衡四七层介绍:**

负载均衡（Load Balance）**建立在现有网络结构之上**，它提供了一种廉价有效透明的方法**扩展网络设备和服务器的带宽**、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。

　　负载均衡有两方面的含义：首先，**大量的并发访问或数据流量分担到多台节点设备上分别处理，减少用户等待响应的时间**；其次，**单个重负载的运算分担到多台节点设备上做并行处理**，每个节点设备处理结束后，**将结果汇总**，返回给用户，系统处理能力得到大幅度提高。

**本地/全局负载均衡**　　

负载均衡从其应用的地理结构上分为本地负载均衡(Local Load Balance)和全局负载均衡(Global Load Balance，也叫地域负载均衡)，本地负载均衡是**指对本地的服务器群做负载**均衡，全局负载均衡是指对**分别放置在不同的地理位置、有不同网络结构的服务器群**间作负载均衡。

　　本地负载均衡能有**效地解决数据流量过大、网络负荷过重**的问题，并且不需花费昂贵开支购置性能卓越的服务器，充分利用现有设备，**避免服务器单点故障造成数据流量的损失**。其有灵活多样的均衡策略把数据流量合理地分配给服务器群内的服务器共同负担。即使是再给现有服务器扩充升级，也只是简单地增加一个新的服务器到服务群中，而不需改变现有网络结构、停止现有的服务。 

　　全局负载均衡主要用于**在一个多区域拥有自己服务器的站点**，为了**使全球用户只以一个IP地址或域名就能访问到离自己最近的服务器，从而获得最快的访问速度**，也可用于子公司分散站点分布广的大公司通过Intranet（企业内部互联网）来达到资源统一合理分配的目的。

## 负载均衡算法
* **轮循均衡**（Round Robin）：每一次来自网络的请求轮流分配给内部中的服务器，从1至N然后重新开始。此种均衡算法适合于服务器组中的**所有服务器都有相同的软硬件配置并且平均服务请求**相对均衡的情况。
* **权重轮循均衡**（Weighted Round Robin）：**根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求**。例如：服务器A的权值被设计成1，B的权值是 3，C的权值是6，则服务器A、B、C将分别接受到10%、30％、60％的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。
* **随机均衡**（Random）：把来自网络的请求**随机分配给内部中**的多个服务器。
* **权重随机均衡**（Weighted Random）：此种均衡算法类似于权重轮循算法，不过在处理请求分担时是个随机选择的过程。
* **响应速度均衡**（Response Time）：负载均衡设备对内部各服务器发出一个探测请求（例如Ping），然后根据内部中各服务器对探测请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求。此种均衡算法能较好的反映服务器的当前运行状态，但这最快响应时间仅仅指的是**负载均衡设备与服务器间的最快响应时间**，而不是客户端与服务器间的最快响应时间。
* **最少连接数均衡**（Least Connection）：客户端的每一次请求服务在服务器停留的时间可能会有较大的差异，随着工作时间加长，如果采用简单的轮循或随机均衡算法，每一台服务器上的连接进程可能会产生极大的不同，并没有达到真正的负载均衡。**最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录，记录当前该服务器正在处理的连接数量，当有新的服务连接请求时，将把当前请求分配给连接数最少的服务器**，使均衡更加符合实际情况，负载更加均衡。此种均衡算法**适合长时处理的请求服务，如FTP**。 
* **处理能力均衡**：此种均衡算法将把服务请求分配给内部中处理负荷（根据服务器CPU型号、CPU数量、内存大小及当前连接数等换算而成）最轻的服务器，由于考虑到了内部服务器的处理能力及当前网络运行状况，所以此种均衡算法相对来说更加精确，尤其适合运用到第七层（应用层）负载均衡的情况下。
* **DNS响应均衡**（Flash DNS）：在Internet上，无论是HTTP、FTP或是其它的服务请求，客户端一般都是通过域名解析来找到服务器确切的IP地址的。在此均衡算法下，分处在不同地理位置的负载均衡设备收到同一个客户端的域名解析请求，并在同一时间内把此域名解析成各自相对应服务器的IP地址（即与此负载均衡设备在同一位地理位置的服务器的IP地址）并返回给客户端，则**客户端将以最先收到的域名解析IP地址来继续请求服务**，而忽略其它的IP地址响应。**在种均衡策略适合应用在全局负载均衡的情况**下，对本地负载均衡是没有意义的。

　　尽管有多种的负载均衡算法可以较好的把数据流量分配给服务器去负载，但如果负载均衡策略没有对网络系统状况的检测方式和能力，一旦在某台服务器或某段负载均衡设备与服务器网络间出现故障的情况下，负载均衡设备依然把一部分数据流量引向那台服务器，这势必造成大量的服务请求被丢失，达不到不间断可用性的要求。所以良**好的负载均衡策略应有对网络故障、服务器系统故障、应用服务故障的检测方式和能力**：

* Ping侦测：通过ping的方式检测服务器及网络系统状况，此种方式简单快速，但只能大致**检测出网络及服务器上的操作系统**是否正常，对服务器上的应用服务检测就无能为力了。
*  TCP Open侦测：每个服务都会开放某个通过TCP连接，检测服务器上某个TCP端口（如Telnet的23口，HTTP的80口等）是否开放来**判断服务是否正常**。
* HTTP URL侦测：比如向HTTP服务器发出一个对main.html文件的访问请求，如果收到错误信息，则认为服务器出现故障。判断应用是否正常

## 负载均衡器的四层和七层负载均衡原理

[四层和七层负载均衡的区别][https://kb.cnblogs.com/page/188170/0]

所谓四层就是基于IP+端口的负载均衡；七层就是基于URL等应用层信息的负载均衡；

同理，还有基于MAC地址的二层负载均衡和基于IP地址的三层负载均衡。换句换说，二层负载均衡会**通过一个虚拟MAC地址**接收请求，然后再分配到真实的MAC地址；三层负载均衡会**通过一个虚拟IP地址**接收请求，然后再分配到真实的IP地址；**四层通过虚拟IP+端口**接收请求，然后**再分配到真实的服务器**；七层通过**虚拟的URL或主机名接收**请求，然后再分配到真实的服务器。

所谓的四到七层负载均衡，就是在对后台的服务器进行负载均衡时，依据**四层的信息或七层的信息来决定怎么样转发流量**。 比如四层的负载均衡，就是通过发布**三层的IP地址（VIP），然后加四层的端口号**，来决定哪些流量需要做负载均衡，对需要处理的流量进行NAT处理，转发至后台服务器，并记录下这个**TCP或者UDP的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理**。七层的负载均衡，就是在四层的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，**还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡**。举个例子，如果你的Web服务器分成两组，一组是中文语言的，一组是英文语言的，那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后**选择对应的语言**服务器组进行负载均衡处理。

　　**③** 负载均衡器通常称为**四层交换机**或**七层交换机**。四层交换机主要分析IP层及TCP/UDP层，实现四层流量负载均衡。**七层交换机除了支持四层负载均衡以外，还有分析应用层的信息**，如HTTP协议**URI或Cookie**信息。

　1、负载均衡分为L4 switch（四层交换），即在OSI第4层工作，就是TCP层啦。此种Load Balance不理解应用协议（如HTTP/FTP/MySQL等等）。例子：LVS，F5。

　2、另一种叫做L7 switch（七层交换），OSI的最高层，应用层。此时，该Load Balancer能理解应用协议。例子：  haproxy，MySQL Proxy。

　　注意：上面的很多Load Balancer既可以做四层交换，也可以做七层交换。

### **四层和七层两者到底区别**

　　**所谓四层负载均衡**，也就是主要通过报文中的**目标地址和端口**，再加上**负载均衡设备设置的服务器选择**方式，决定最终选择的内部服务器。

TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标**IP地址进行修改**(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证**服务器回包**可以正确返回给负载均衡设备，在转发报文的同时可能还会**对报文原来的源地址**进行修改。

**所谓七层负载均衡**，也称为“内容交换”，也就是主要通过**报文中的真正有意义的应用层**内容，再加上**负载均衡设备设置的服务器选择方式**，决定最终选择的内部服务器。

　　以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能**先代理最终的服务器和客户端建立连接(三次握手)后**，才可能**接受到客户端发送的真正应用层内容的报文**，然后再根据该**报文中的特定字段**，再加上**负载均衡设备设置的服务器选择**方式，决定**最终选择的内部服务器**。负载均衡设备在这种情况下，更类似于一个代理服务器。**负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接**。所以从这个技术原理上来看，**七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式**。

![image-20201213224438232](/Users/yangyibo/Library/Application Support/typora-user-images/image-20201213224438232.png)

### 好处

七层应用负载的好处，是使得整个网络更"**智能化**"。例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将**对文字类的请求可**以转发到特定的文字服务器并可以使用压缩技术。从技术原理上，这种方式**可以对客户端的请求和服务器的响应进行任意意义上的修改**，极大的提升了应用系统在网络层的灵活性。很多在后台，例如Nginx或者Apache上部署的功能可以前移到负载均衡设备上，例如客户请求中的Header重写，服务器响应中的关键字过滤或者内容插入等功能。

　　另外一个常常被提到功能就**是**安全性。网络中最常见的SYN Flood攻击，即黑客控制众多源客户端，使用虚假IP地址对同一目标发送SYN攻击，通常这种攻击会大量发送SYN报文，耗尽服务器上的相关资源，以达到Denial of Service(*DoS*)的目的。从技术原理上也可以看出，四层模式下这些SYN攻击都会被转发到后端的服务器上；而七层模式下这些SYN攻击自然在负载均衡设备上就截止，不会影响后台服务器的正常运营。另外负载均衡设备可以在七层层面设定多种策略，过滤特定报文，例如SQL Injection等应用层面的特定攻击手段，从应用层面进一步提高系统整体安全。

　　现在的7层负载均衡，主要还是着重于**应用**HTTP协议，所以其应用范围主要是众多的网站或者内部信息平台等基于B/S开发的系统。 4层负载均衡则对应其他TCP应用，例如基于C/S开发的ERP等系统。

**问题**：

* **是否真的必要**：带来设备配置复杂，负载均衡压力增高以及故障排查上的复杂性等问题。在设计系统时需要考虑四层七层同时应用的混杂情况。
* **是否真的可以提高安全性**。例如SYN Flood攻击，七层模式的确将这些流量从服务器屏蔽，但**负载均衡设备本身要有强大的抗DDoS能力**，否则即使服务器正常而作为中枢调度的负载均衡设备故障也会导致整个应用的崩溃。
* **是否有足够的灵活度**。七层应用的优势是可以让整个应用的流量智能化，但是负载均衡设备需要提供完善的七层功能，满足客户**根据不同情况的基于应用的调度**。最简单的一个考核就是能否取代后台Nginx或者Apache等服务器上的调度功能。能够提供一个七层应用开发接口的负载均衡设备，可以让客户根据需求任意设定功能，才真正有可能提供强大的灵活性和智能性。







技术选型，

项目难点总结。

少说，交互



next key

remberset

mysql 架构

mysql 食物事物隔离级别

mq死信队列

















