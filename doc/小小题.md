小小题：

**1. System.gc() 和 Runtime.gc() 会做什么事情？**

这两个方法用来提示 JVM 要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于 JVM 的。

 System.gc()  触发的是 full gc

**2. Java 中会存在内存泄漏吗，请简单描述。**
所谓**内存泄露**就是指一个**不再被程序使用的对象或变量一直被占**
**据在内存中**。

Java 中的内存泄露的情况：**长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露**，**尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收**。

通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的。

 **3. finalize() 方法什么时候被调用？析构函数 (finalization) 的目的是什么？**

垃圾回收器（garbage colector）决定回收某对象时，就会运行该对象的 finalize() 方法 但是在 Java 中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说 filalize() 可能永远不被执行，显然指望它做收尾工作是靠不住的。 finalize() 最主要的用途是回收特殊渠道申请的内存。Java 程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种 JNI（Java Native Interface）调用non-Java 程序（C 或 C++）， finalize() 的工作就是回收这部分的内存

**4.类加载器双亲委派模型机制？**
当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类
去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。

1. hashmap 为什么不安全

2. 一致性hash算法

3. 索引哪些情况会失效

4. 走索引仍然慢？ SQL很复杂，优化SQL结构，表数据量太大，索引过滤性不好，加载了不必要的字段/数据




## 1. 在100G文件8G内存中找出出现次数最多的100个IP?

思路：分治思想+排序

1. 由于100G文件加载不到内存，所以需要分治
2. 100G文件按照每5G一个文件拆分为20个文件，拆分文件时通过判断IP的A、B、C、段进行拆分，**尽量拆分平均，且相同IP拆分在同一文件中**，。当然也可以按照 IP转 long型，hash 分文件。（分表思想）
3. 分别计算每个文件中IP的出现次数。对单个文件进行计数统计，此步可以使用hashmap计数。
4. 使用堆排序计算出每个文件中取最多次的100IP
5. 合并所有文件计算出的100IP进行合并，再进行堆排序获取最多次100IP

为什么使用堆排序？

因为堆排序在处理找Top 问题上基于二分查找，复杂度时O(NlogK) ，而快排是 O(N)。

## 2. 100G大文件单机处理找到第一个不重复的字符串，16G内存限制

首先，不重复则说明需要遍历全文件，其次要记录每个字符串在原文件中第一次出现的位置

思路分治：

1. 将大文件切分成多个小文件。
2. 文件大小**尽量均匀**达到我们设置的内存，最重要的一点是**保证相同字符串要在同一个文件中**，用到Hash函数，相同字符串的hash函数值是相同的。存在极特殊情况某一段字符串很多，使得小文件分布不均匀，则遍历文件对一次分割文件变大的文件按照所占内存大小重新分割。
3. 切分文件时，每份文件中要记录每行的字符串内容以及在源文件中第一次出现的位置，用long型来存储
4. 读小文件把其存到内存中，分别计算每个文件中的**每个字符串其出现频率和第一次出现的位置**。每个文件**保存一个结果**，即**频率为1且最早出现的字符串信息**，以后遍历的每个文件中若有频率为1且更早索引位置的，将原有结果替换。最后返回第一个不重复的字符串。
5. 关于第 4步的字符串出现频率统计可用：
   * 维护一张hashmap在读取的时候统计词频，在内存范围内，统计词频，最后遍历只出现一次的字符串然后用堆排序选出该文件出现最早的字符串

# 内存溢出+CPU占用过高:问题排查+解决方案+复盘

https://zhanghan.blog.csdn.net/article/details/109255980

- 排查内存溢出的思路
- 排查内存溢出过程中用到的命令及工具（Linux命令，[Eclipse Memory Anaylzer[MAT\]](https://www.eclipse.org/mat/)）
- 定位系统内存溢出的代码，并进行优化
- 此次内存溢出问题复盘

**问题：**

- 业务反馈程序用的十分卡，同时测试自己测的也十分卡
- 请求日志发现确实存在问题，线上是两台部署：两台机器上都是，一次请求耗时由原来的几毫秒变为10几秒
- CPU跑的过高，当时是4核，CPU持续飙到350%+；

临时解决方案：**重启**

- 当时为了减少对业务影响，直接将生产两台服务器上的项目进行重启
- 项目**启动参数中**没有加内存溢出日志输出（后续博客为大家介绍JVM调优时讲解启动命令中**加内存溢出日志输出**），重启后出问题时项目的JVM信息丢失了

复现问题方式：在开发环境对程序进行持续压测;压测相关服务器配置

**定位问题**

- **top命令**查看最耗CPU的进程（进程:17038;CPU持续飙到595%+）

- 查看**该进程中最耗CPU的线程**(发现有一些线程占用CPU较高)  
  ```shell
  top -Hp pid 
  ```

- 将线程号转为16进制,同时查看这些线程当前正在干什么（在此以17045线程为例）

  ```shell
  printf '%x\n' 17045
  # 17038为进程号,0x4295为最耗CPU线程的十六进制
  jstack 17038 | grep '0x4295' -C10 --color
  ```

* 可以看到**最耗CPU的线程都是在进行GC**

* 用Jmap命令查看当前堆的使用情况(发现老年代现在已占用99.8%+)
  ```shell
  jmap -heap 17038
  ``
  ```
```
  
* 查看gc频率的命令（其中O代表老年代占用率，FGC是FullGC次数，FGCT是fullGC时间；可以看出在频繁FullGC但是老年代有资源一直释放不掉）

  ```shell
  jstat -gcutil 17038 5000
```

* 通过**分析出问题时线上日志**发现内存溢出；至此定位到问题根源是内存溢出导致（有未释放资源堆积，导致老年代被占满，然后频繁的FullGC但是资源一直释放不了）

  ```shell
  grep -m 10 'OutOfMemoryError' *.log
  ```

* 分析问题产生原因

* 由于线上当时直接重启，未能保留当时的JVM内存文件；在**开发环境进行循环压测，复现线上问题**，然后**导出dump文件进行分析**找到原因。生成dump文件命令

  ```shell
  # 生成dump文件命令
  # 其中fileName是导出后dump名称,pid为进程号
  jmap -dump:format=b,file=fileName.dump pid
  
  ```
  
* 将dump文件导出到本地，用Eclipse Memary Analysis（MAT[官网下载地址](https://www.eclipse.org/mat/downloads.php)） 进行分析

  而在idea中也有这么一个插件，就是**JProfilerl**。  MAT导入dump文件,按对象排序视图进行查看。
  
* 分析内存占用类，查看代码为何释放不掉。然后进行代码优化

* 优化后再次进行验证，压测和dump 文件分析

## 预警：

- 程序预警：为减少业务影响，增加接口耗时的预警（后续博文为大家共享）；实现方式：
  \- 在每次程序处理完进行预警（比如本次请求>阈值）;缺点：消耗性能影响正常业务
  \- 在ELK清洗时用相关插件进行预警；优点：和业务解耦，对业务无影响
- 服务器预警：运维增加CPU内存，日志内存溢出监控

## 总结

1. 发现问题，重启大法。故障重现

2. jsp 或者 ps -ef | grep 命令查询 PID

3. top pid 查看cpu 情况

4. top -Hp pid  查看进程下有问题的 线程

5. 将线程号转为16进制，查看线程在干什么是否在GC或者其他的事情，然后在根据情况分析

   ```shell
   # 将线程号转为16进制  17045 为线程号
   printf '%x\n' 17045
   # 17038为进程号,0x4295为最耗CPU线程的十六进制
   jstack 17038 | grep '0x4295' -C10 --color
   ```

6. jmap -heap 17038 用Jmap命令查看当前堆的使用情况，看fullGC 后，老生代内存是否释放，youngGC 后 新生代GC后内存是否释放。**如果fullGC 后老生代内存 内存仍然很高**，此时dump 出线程日志，分析问题。看是需要增加内存还是内存溢出、泄漏

   ```shell
   # 生成dump文件命令
   # 其中fileName是导出后dump名称,pid为进程号
   jmap -dump:format=b,file=fileName.dump pid
   
   ```

7. 通过eclipse 的 MAT  或者idea 的 JProfilerl 插件进行dump 文件分析，分析有问题的类。分析代码，进行排查，优化。

   

































