# jvm 的堆、栈、方法区

https://www.cnblogs.com/andy-zhou/p/5327288.html
https://www.cnblogs.com/woshimrf/p/jvm-garbage.html
https://blog.csdn.net/qq_31337311/article/details/78799262
https://blog.csdn.net/u012998254/article/details/81428621

###0、栈是运行时单位，而堆是存储的单位。

栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。

在Java中一个线程就会相应有一个线程栈与之对应，这点很容易理解，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等；而堆只负责存储对象信息。

### 1、java中的栈（stack）和堆（heap）是java在内存（ram）中存放数据的地方

* （1）当程序运行时，首先通过类装载器加载字节码文件，经过解析后装入方法区！在方法区中存了类的各种信息，包括类变量、常量及方法。对于同一个方法的调用，同一个类的不同实例调用的都是存在方法区的同一个方法。类变量的生命周期从程序开始运行时创建，到程序终止运行时结束！ 
* （2）当程序中new一个对象时，这个对象存在堆中，对象的变量存在栈中，指向堆中的引用！对象的成员变量都存在堆中，当对象被回收时，对象的成员变量随之消失！ 
* （3）当方法调用时，JVM会在栈中分配一个栈桢，存储方法的局部变量。当方法调用结束时，局部变量消失！

###2、堆中存什么？栈中存什么？

堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。一个对象的大小是不可估计的，或者说是可以动态变化的，但是在栈中，一个对象只对应了一个4btye的引用（堆栈分离的好处：））。

为什么不把基本类型放堆中呢？因为其占用的空间一般是1~8个字节——需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的（还会浪费空间，后面说明）。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据。最常见的一个问题就是，Java中参数传递时的问题。

对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。

### 3、堆区  对象、成员变量

* 存储的全部是对象，每个对象都包含一个与之对应的class的信息.（class的目的是得到操作指令）；
* jvm只有一个heap区，被所有**线程共享**，不存放基本类型和对象引用，只存放对象本身。
* **堆的优劣势**：堆的优势是可以动态的分配内存大小，生存期也不必事先告诉编译器，java的垃圾收集器会自动收取这些不在使用的数据，但缺点是，由于要在运行时动态分配内存，存取速度慢。

### 3、栈区 局部变量 

* 每一个线程包含一个stack区，只保存**基本数据类型的对象和自定义对象的引用（不是对象**），对象都存放在共享heap中；每个栈中的数据（基本数据类型和对象引用）都是私有的，其他栈不能访问；栈分为3部分：基**本类型变量区**、**执行环境上下文**、操作指令区（存放操作指令）
* 栈的优势劣势：**存取速度比堆要快**，仅次于直接位于CPU的寄存器，但**必须确定的是存在stack中的数据大小与生存期**必须是确定的，**缺乏灵活性**。
* 单个stack的数据可以共享。在java中，所有基本类型和引用类型都在stack中储存，栈中数据的生存空间一般在当前scopes内

####方法区（Method Area）

方法区（Method Area）：与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。很多人都更愿意把方法区称为“永久代”（Permanent Generation）。从jdk1.7已经开始准备“去永久代”的规划，jdk1.7的HotSpot中，已经把**原本放在方法区中的静态变量、字符串常量池等移到堆内存**中。

**在jdk1.8中，永久代已经不存在，存储的类信息、编译后的代码数据等已经移动到了元空间**（MetaSpace）中，元空间并没有处于堆内存上，而是直接占用的本地内存（NativeMemory）

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小

### 4、方法区 类信息、类变量（静态变量和常量）、方法

* 1、方法区又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量；
* 2、方法区中包含的都是在程序中永远的唯一的元素

* 常量池 (放在方法区)
  * Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。
  * 所谓静态常量池，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。
  * 而运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池
  * 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。
  * 栈：在Java中，JVM中的栈记录了线程的方法调用。每个线程拥有一个栈。在某个线程的运行过程中，如果有新的方法调用，那么该线程对应的栈就会增加一个存储单元，即帧(frame)。在frame中，保存有该方法调用的参数、局部变量和返回地址。
  * 堆：是JVM中一块可自由分配给对象的区域。当我们谈论垃圾回收(garbage collection)时，我们主要回收堆(heap)的空间。
    Java的普通对象存活在堆中。与栈不同，堆的空间不会随着方法调用结束而清空。因此，在某个方法中创建的对象，可以在方法调用结束之后，继续存在于堆中。这带来的一个问题是，如果我们不断的创建新的对象，内存空间将最终消耗殆尽。

##GC

新生代由于其对象存活时间短，且需要经常gc，因此采用效率较高的复制算法，其将内存区分为一个eden区和两个suvivor区，eden区和survivor区的比例是8:1，分配内存时先分配eden区，当eden区满时，使用**复制算法**进行gc，将存活对象复制到一个survivor区，当一个survivor区满时，将其存活对象复制到另一个区中，当对象存活时间大于某一阈值时，将其放入老年代。 
老年代和永久代因为其存活对象时间长，因此使用**标记清除或标记整理算法**



## 按照基本回收策略分

* 引用计数（Reference Counting）:

比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。**此算法最致命的是无法处理循环引用的问题**。

* 标记-清除（Mark-Sweep）:
  此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。**此算法需要暂停整个应用，同时，会产生内存碎片**。

* 复制（Copying）:

此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，**遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。**次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此**算法的缺点也是很明显的，就是需要两倍内存空间**。

**商业虚拟机用这个回收算法来回收新生代**

* 标记-整理（Mark-Compact）:

此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。

**老年代标记-清理“和”标记-整理“算法来进行回收。**

##Java中可以作为GC Root的对象有

* 虚拟机栈中引用的对象（本地变量表）
* 方法区中静态属性的引用对象
* 方法区中常量引用对象
* 本地方法栈中引用对象（Native 对象）
* 主要执行在上下文中和全局性的引用

#分区对待的方式分

* 增量收集（Incremental Collecting）:
  实时垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么原因JDK5.0中的收集器没有使用这种算法的。

* 分代收集（Generational Collecting）:
  基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青代、年老代、持久代，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的。

#为什么要分代

分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。

#什么情况下触发垃圾回收

由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。jdk1.8 后分为 Minor GC、Major GC和Full GC，清理Eden区和 Survivor区叫Minor GC。清理Old区叫Major GC。清理整个堆空间—包括年轻代和老年代叫Full GC。

##Scavenge GC

一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。

##Full GC

对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：

* 年老代（Tenured）被写满
* 持久代（Perm）被写满 
* System.gc()被显示调用 
* 上一次GC之后Heap的各域分配策略动态变化

##GC

新生代由于其对象存活时间短，且需要经常gc，因此采用效率较高的复制算法，其将内存区分为一个eden区和两个suvivor区，eden区和survivor区的比例是8:1，分配内存时先分配eden区，当eden区满时，使用**复制算法**进行gc，将存活对象复制到一个survivor区，当一个survivor区满时，将其存活对象复制到另一个区中，当对象存活时间大于某一阈值时，将其放入老年代。 
老年代和永久代因为其存活对象时间长，因此使用**标记清除或标记整理算法**


# 垃圾回收的瓶颈

传统分代垃圾回收方式，已经在一定程度上把垃圾回收给应用带来的负担降到了最小，把应用的吞吐量推到了一个极限。但是他无法解决的一个问题，就是Full GC所带来的应用暂停。在一些对实时性要求很高的应用场景下，GC暂停所带来的请求堆积和请求失败是无法接受的。这类应用可能要求请求的返回时间在几百甚至几十毫秒以内，如果分代垃圾回收方式要达到这个指标，只能把最大堆的设置限制在一个相对较小范围内，但是这样有限制了应用本身的处理能力，同样也是不可接收的。

分代垃圾回收方式确实也考虑了实时性要求而提供了并发回收器，支持最大暂停时间的设置，但是受限于分代垃圾回收的内存划分模型，其效果也不是很理想。

为了达到实时性的要求（其实Java语言最初的设计也是在嵌入式系统上的），一种新垃圾回收方式呼之欲出，它既支持短的暂停时间，又支持大的内存空间分配。可以很好的解决传统分代方式带来的问题。

# 类加载



实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。

主要有一下四种类加载器:
1. 启动类加载器(Bootstrap ClassLoader)用来加载 java 核心类库，无法被 java 程序直接引用。
2. 扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
3. 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。
4. 用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。



## G1

G1垃圾回收器中。标记-复制算法可以分为三个阶段：

- **标记阶段**，即从GC Roots集合开始，标记活跃对象；
- **转移阶段**，即把活跃对象复制到新的内存地址上；
- **重定位阶段**，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。

**1.标记阶段停顿分析**

**初始标记阶段**：初始标记阶段是指从GC Roots出发标记全部直接子节点的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。

**并发标记阶段**：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。

**再标记阶段：**重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。

**2.清理阶段停顿分析**



清理阶段清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的。



**3.复制阶段停顿分析**



复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。



四个STW过程中，初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。因此，G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW。为什么转移阶段不能和标记阶段一样并发执行呢？主要是G1未能解决转移过程中准确定位对象地址的问题。



G1的Young GC和CMS的Young GC，其标记-复制全过程STW，这里不再详细阐述。

## ZGC

The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器，它的**设计目标**包括：

- 停顿时间不超过10ms；
- 停顿时间不会随着堆的大小，或者活跃对象的大小而增加；
- 支持8MB~4TB级别的堆（未来支持16TB）。

从设计目标来看，我们知道ZGC适用于大内存低延迟服务的内存管理和回收。

ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。

### ZGC关键技术

ZGC通过**着色指针**和**读屏障**技术**，解决了转移过程中准确访问对象的问题，实现了并发转移**。**大致原理描述如下**：并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在ZGC中，**应用线程访问对象将触发“读屏障”**，如果发现对象被移动了，那么**“读屏障”会把读出来的指针更新到对象的新地址上**，这样应用线程始终访问的都是对象的新地址。那么，**JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针**。

## 着色指针

**着色指针是一种将信息存储在指针中的技术**。**ZGC仅支持64位系统，它把64位虚拟地址空间划分为多个子空间**，如下图所示：

CPU的位是指一次性可处理的数据量是多少，1字节=8位，32位处理器可以一次性处理4个字节的数据量，64位处理器一次性可以处理64个字节。

32位和64位处理器还涉及到内存的寻址方面，32位系统的处理器最大只支持到4G内存，而64位系统最大支持的内存高达亿位数。 这也是如今人们纷纷淘汰32位系统的主要原因



读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅“从堆中读取对象引用”才会触发这段代码。

读屏障示例：

```Java
Object o = obj.FieldA   // 从堆中读取引用，需要加入屏障
<Load barrier>
Object p = o  // 无需加入屏障，因为不是从堆中读取引用
o.dosomething() // 无需加入屏障，因为不是从堆中读取引用
int i =  obj.FieldB  //无需加入屏障，因为不是对象引用
```

接下来详细介绍ZGC一次垃圾回收周期中地址视图的切换过程：

- **初始化**：ZGC初始化之后，**整个内存空间的地址视图被设置为Remapped**。程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入标记阶段。
- **并发标记阶段**：第一次进入标记阶段时**视图为M0**，如果**对象被GC标记线程或者应用线程访问过**，那么就将对象的**地址视图从Remapped调整为M0**。所以，在标记阶段结束之后，对象的地址要么是M0视图，要么是Remapped。如**果对象的地址是M0视图，那么说明对象是活跃的**；如果对象的地址是Remapped视图，说明对象是不活跃的。
- **并发转移阶段**：标记结束后就进入转移阶段，此时地址视图再次被设置为Remapped。如果**对象被GC转移线程或者应用线程访问过，那么就将对象的地址视图从M0调整为Remapped**。

其实，在标记阶段存在**两个地址视图M0和M1**，上面的过程显示只用了一个地址视图。之所以设计成两个，是为了**区别前一次标记和当前标记**。也即，**第二次进入并发标记阶段后，地址视图调整为M1**，而非M0。

**着色指针**和**读屏障**技术**不仅应用在并发转移阶段，还应用在并发标记阶段：将对象设置为已标记**，**传统的垃圾回收器需要进行一次内存访问，并将对象存活信息放在对象头中**；而在ZGC中，**只需要设置指针地址的第42~45位即可，并且因为是寄存器访问，所以速度比访问内存更快**。





ZGC（The Z Garbage Collector）

**关键技术：**着色指针、读屏障

**算法：标记-复制算法**（重大改进，ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因）

**过程：**

ZGC只有三个STW阶段：**初始标记**，**再标记**，**初始转移**。其中，初始标记和初始转移分别都只需要扫描所有GC Roots，其处理时间和GC Roots的数量成正比，一般情况耗时非常短；

**再标记阶段STW时间很短**，最多1ms，超过1ms则再次进入**并发标记阶段**（通过着色指针技术，准确访问对象，做到并发转移）。即，**ZGC几乎所有暂停都只依赖于GC Roots集合大小**，**停顿时间不会随着堆的大小或者活跃对象的大小而增加**。与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。

**关键技术：**

ZGC通过**着色指针**和**读屏障**技术，解决了**转移过程中准确访问对象的问题，实现了并发转移**。大致原理描述如下：并发转移中“并发”意味着**GC线程在转移对象的过程中，应用线程也在不停地访问对象**。**假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址**。那么，JVM是通过**对象引用的地址，即着色指针**，判断对象是否被移动。

**优点：**

- 停顿时间不超过10ms；
- 停顿时间不会随着堆的大小，或者活跃对象的大小而增加；
- 支持8MB~4TB级别的堆（未来支持16TB）。




字节码

魔法类

hashmap