#琐事
##查看redhat ip
```
ip addr 
```
##修改Linux 的静态ip
```
/etc/sysconfig/network-scripts/ifcfg-eth0

 BOOTPROTO=STATIC
 IPADDR=192.168.100.5
 NETMASK=255.255.255.0
 GATEWAY=192.168.100.1
 ONBOOT=yes
```
rhel7 断网 注释GATEWAY=192.168.100.1
##Linux解决Device eth0 does not seem to be present 
解决办法：

首先，打开/etc/udev/rules.d/70-persistent-net.rules内容如下面例子所示：

```
# vi /etc/udev/rules.d/70-persistent-net.rules
# This file was automatically generated by the /lib/udev/write_net_rules
# program, run by the persistent-net-generator.rules rules file.
#
# You can modify it, as long as you keep each rule on a single
# line, and change only the value of the NAME= key.
# PCI device 0x1022:0x2000 (pcnet32)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:0c:29:8f:89:9
7", ATTR{type}=="1", KERNEL=="eth*", NAME="eth0"
# PCI device 0x1022:0x2000 (pcnet32)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:0c:29:50:bd:1
7", ATTR{type}=="1", KERNEL=="eth*", NAME="eth1"

记录下，eth1网卡的mac地址00:0c:29:50:bd:17

接下来，打开/etc/sysconfig/network-scripts/ifcfg-eth0

# vi /etc/sysconfig/network-scripts/ifcfg-eth0

将 DEVICE="eth0"  改成  DEVICE="eth1"  ,
将 HWADDR="00:0c:29:8f:89:97" 改成上面的mac地址  HWADDR="00:0c:29:50:bd:17"

最后，重启网络

# service network restart
```
参考：http://www.linuxidc.com/Linux/2012-12/76248.htm

##redhat6.5修改主机名

```
vi /etc/sysconfig/network
修改HOSTNAME项
HOSTNAME=XXX
reboot
```
##linux cgroup
Linux CGroup全称Linux Control Group， 是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）

最早的名称为进程容器（process containers）。在2007年时，因为在Linux内核中，容器（container）这个名词太过广泛，为避免混乱，被重命名为cgroup，
##配置Linux 联网
编辑 /etc/resolv.conf 添加内容如下：

```
nameserver 8.8.8.8
nameserver 8.8.4.4
```
##查看Linux版本
```
uname -a 
或
cat /proc/version
或
cat /etc/redhat-release  
或 
cat /etc/issue     －－redhat 6.5 一下。
或
cat /etc/redhat-release
```
## linux 关闭防火墙

```
systemctl stop firewalld.service
systemctl disable firewalld.service	
```
### rhel 6.5 关闭防火墙
* 关闭防火墙-----service iptables stop
* 启动防火墙-----service iptables start
* 重启防火墙-----service iptables restart
* 查看防火墙状态--service iptables status
* 永久关闭防火墙--chkconfig iptables off
* 永久关闭后启用--chkconfig iptables on
* 最后两个命令同时运行，运行完成后查看防火墙关闭状态 
* service iptables status

##linux rpm包下载
http://vault.centos.org/6.3/os/x86_64/Packages/
http://rpm.pbone.net/index.php3

##rpm 包命令
```
安装rpm  
rpm -ivh

--force 参数为重复替换
--nodeps 参数为强制安装，忽略依赖

列出rpm包的内容：
rpm -qpl *.rpm

解压rpm包的内容：（没有安装，就像解压tgz包一样rpm包）
rpm2cpio *.rpm | cpio -div
```
##linux 修改时区
1. 执行tzselect命令-->选择Asia-->选择China-->选择east China - Beijing, Guangdong, Shanghai, etc-->然后输入1

	如果不想用tzselect命令，可以修改文件变更时区。  vi /etc/sysconfig/clock  

	```
	ZONE=Asia/Shanghai（查/usr/share/zoneinfo下面的文件） 
	UTC=false 
	ARC=false
	```
2. rm /etc/localtime3、链接到上海时区文件       
3. ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime  重启机器

##Redhat7.1
vi /etc/hostname
hostnamectl set-hostname your_hostname 
修改 redhat 7.1 的hostname

#shell
eval命令将会首先扫描命令行进行所有的替换，憨厚再执行命令。
##shell生成随机数
生成1-60 的随机数

```
 #!/bin/bash
 
 echo "$((($RANDOM)%60))"
```
##判断上一条命令是否执行成功
```
if [ $? -eq 0 ];
then
	echo "执行成功";
else
	echo "执行失败";
fi
```
##shell 判断

```
#!/bin/sh
myPath="/var/log/httpd/"
myFile="/var /log/httpd/access.log"

# 这里的-x 参数判断$myPath是否存在并且是否具有可执行权限
if [ ! -x "$myPath"]; then
 mkdir "$myPath"
fi
# 这里的-d 参数判断$myPath是否存在
if [ ! -d "$myPath"]; then
 mkdir "$myPath"
fi

# 这里的-f参数判断$myFile是否存在
if [ ! -f "$myFile" ]; then
 touch "$myFile"
fi
# 其他参数还有-n,-n是判断一个变量是否是否有值
if [ ! -n "$myVar" ]; then
 echo "$myVar is empty"
 exit 0
fi

# 两个变量判断是否相等
if [ "$var1" = "$var2" ]; then
 echo '$var1 eq $var2'
else
 echo '$var1 not eq $var2'
fi
```
##!/bin/sh 与 !/bin/bash
/bin/sh 与 /bin/bash 虽然大体上没什么区别, 但仍存在不同的标准. 标记为 “#!/bin/sh” 的脚本不应使用任何 POSIX 没有规定的特性 (如 let 等命令, 但 “#!/bin/bash” 可以). Debian 曾经采用 /bin/bash 更改 /bin/dash，目的使用更少的磁盘空间、提供较少的功能、获取更快的速度。但是后来经过 shell 脚本测试存在运行问题。因为原先在 bash shell 下可以运行的 shell script (shell 脚本)，在 /bin/sh 下还是会出现一些意想不到的问题，不是100%的兼用。
##从终端读取参数
-t 30 等待30s

-p "The para is params "  // 提示信息

```
#!/bin/sh
params=0;
#Read the params . Set The finalEnv. Pay Attention 'read' NOT 'Read'
read -t 30 -p "The para is params " params ;
echo "$params"
```
##从配置文件中读取数据
env.properties

```
flume_path=/opt/apps/wh.agent/current
epp_path=/opt/apps/epp_manager

prop_package=epp-manager
prop_appRoot=/opt/apps
```
注意：参数名不要用点隔开，应用下划线。 //test.sh

```
#!/bin/sh
. env.properties
finalPackage=${flume_path}
echo "$finalPackage"
```
##从配置文件中读取（二）

```
	VALUES=`grep "^flume_path" env.properties|grep -v \# |cut -d'=' -f2`;

```
通过查询的方式获取参数 ，^ 以此为开头。 grep -v \# 忽略以＃开头的记录
##数组

```
#declare -a: define an array
#declare -i: define an integer
declare -i index=1
declare -a envMap
declare -a formatMap=(["1"]="docker" ["2"]="springboot")


#scan the env  all dir to envMap
for i in env/* ; do 
 if [ -d ${i} ]; then
	envMap["${index}"]="`basename ${i}`"
	index=index+1
 fi
done

#使用@ 或 * 可以获取数组中的所有元素
#print envMap all element
for i in ${!envMap[@]} ;do
	echo [${i}]:${envMap[${i}]}
done

```
##shell运算符

```
==	相等。用于比较两个数字，相同则返回 true。	[ $a == $b ] 返回 false。

-eq	检测两个数是否相等，相等返回 true。	[ $a -eq $b ] 返回 false。

=	检测两个字符串是否相等，相等返回 true。	[ $a = $b ] 返回 false。

!=	检测两个字符串是否相等，不相等返回 true。	[ $a != $b ] 返回 true。

-z	检测字符串长度是否为0，为0返回 true。	[ -z $a ] 返回 false。

-n	检测字符串长度是否为0，不为0返回 true。	[ -n $a ] 返回 true。

-d file	检测文件是否是目录，如果是，则返回 true。	[ -d $file ] 返回 false。

-f file	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。	[ -f $file ] 返回 true。
```
##egrep
Linux egrep命令用于在文件内查找指定的字符串。
egrep执行效果与"grep-E"相似，使用的语法及参数可参照grep指令，与grep的不同点在于解读字符串的方法。
egrep是用extended regular expression语法来解读的，而grep则用basic regular expression 语法解读，extended regular expression比basic regular expression的表达更规范。

```
egrep [范本模式] [文件或目录] 
egrep Linux * 
 //查找当前目录下所有文件中包含字符串"Linux"的文件
```
##echo -e
```
echo -e "OK! \n" # -e 开启转义
```
##sed -i
Linux sed命令是利用script来处理文本文件。
sed可依照script的指令，来处理、编辑文本文件。
Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。

* i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；

##sh -c  "。。。"
从String中读取命令 并处理他们
##curl 
-d 传递参数 -o将输出重定向到一个文件（多用于下载文件）-s curl 在安静模式下执行，不会发送任何数据到stdout
```
curl -d "status=pedding" -o /dev/null -s $URL
```
#java

##java 字符串判断
判断某字符串是否为空或长度为0或由空白符(whitespace)构成
下面是示例：

```
StringUtils.isBlank(null) = true
StringUtils.isBlank("") = true
StringUtils.isBlank(" ") = true
StringUtils.isBlank(" ") = true
StringUtils.isBlank("\t \n \f \r") = true //对于制表符、换行符、换页符和回车符StringUtils.isBlank()均识为空白符
StringUtils.isBlank("\b") = false //"\b"为单词边界符
StringUtils.isBlank("bob") = false
StringUtils.isBlank(" bob ") = false
```
2.public static boolean isEmpty(String str)
判断某字符串是否为空，为空的标准是str==null或str.length()==0
下面是StringUtils判断是否为空的示例：

```
StringUtils.isEmpty(null) = true
StringUtils.isEmpty("") = true
StringUtils.isEmpty(" ") = false //注意在StringUtils中空格作非空处理
StringUtils.isEmpty(" ") = false
StringUtils.isEmpty("bob") = false
StringUtils.isEmpty(" bob ") = false
```
##spring4 时间

```
//使用瞬时时间 + 时区  
Instant instant = Instant.now();  
LocalDateTime d3 = LocalDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());  
System.out.println(d3);  
```

##jvm内存
* JDK1.7后，常量池被放入到堆空间中。方法是放在栈里面的。
* 从栈内存里面去数据要快一些。
* JVM有两类存储区：常量缓冲池和方法区
* 常量缓冲池用于存储类名称、方法和字段名称以及字符串常量。
方法区则用于存储Java方法的字节码。

##intern()
* intern()方法设计的初衷，就是重用String对象，以节省内存消耗。
* 使用intern() 方法创建字符串，当常量池中已经包含一个等于此 String 对象的字符串（用 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并返回此 String 对象的引用。 

##replace和replaceAll的区别
* 1)replace的参数是char和CharSequence，即可以支持字符的替换，也支持字符串的替换(CharSequence即字符串序列的意思,说白了也就是字符串)；
* 2)replaceAll的参数是regex，即基于规则表达式的替换，比如，可以通过replaceAll("\\d", "*")把一个字符串所有的数字字符都换成星号;
* 相同点：都是全部替换，即把源字符串中的某一字符或字符串全部换成指定的字符或字符串，如果只想替换第一次出现的，可以使用replaceFirst()，这个方法也是基于规则表达式的替换，但与replaceAll()不同的是，只替换第一次出现的字符串；
* 另外，如果replaceAll()和replaceFirst()所用的参数据不是基于规则表达式的，则与replace()替换字符串的效果是一样的，即这两者也支持字符串的操作；
* 还有一点注意:：执行了替换操作后,源字符串的内容是没有发生改变的。

##StringBuilder & StringBuffer
* StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。
* String类是不可变类，任何对String的改变都 会引发新的String对象的生成(除了intern())；StringBuffer则是可变类，任何对它所指代的字符串的改变都不会产生新的对象。

##java 基本数据类型
又称为原始数据类型byte,short,char,int,long,float,double,boolean，他们之间的比较应该使用（==），比较的是他们的值。
##java  复合数据类型
当复合数据类型用（==）进行比较，比较的是他们在内存中的存放地址。
当复合数据类型之间进行equals比较时，这个方法的初始行为是比较对象在堆内存中的地址，但在一些诸如String,Integer,Date类中把Object中的这个方法覆盖了，作用被覆盖为比较内容是否相同。
##TreeMap和HashMap
* HashMap：适用于在Map中插入、删除和定位元素。 
* Treemap：适用于按自然顺序或自定义顺序遍历键(key)。 
* HashMap通常比TreeMap快一点(树和哈希表的数据结构使然)，建议多使用HashMap，在需要排序的Map时候才用TreeMap。 
###Treemap
Treemap的实现是红黑树算法的实现，红黑树是一颗自平衡的排序二叉树；对红黑二叉树而言它主要包括三大基本操作：左旋、右旋、着色。
一棵有效的红黑树二叉树而言我们必须增加如下规则：
       * 1、每个节点都只能是红色或者黑色
       * 2、根节点是黑色
       * 3、每个叶节点（NIL节点，空节点）是黑色的。
       * 4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。
       * 5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
       
##Map.Entry
Map是java中的接口，Map.Entry是Map的一个内部接口。

Map提供了一些常用方法，如keySet()、entrySet()等方法，keySet()方法返回值是Map中key值的集合；entrySet()的返回值也是返回一个Set集合，此集合的类型为Map.Entry。

Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry<K,V>。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue方法。

###Map.Entry使用

你是否已经对每次从Map中取得关键字然后再取得相应的值感觉厌倦？使用Map.Entry类，你可以得到在同一时间得到所有的信息。

```
 //第三种：推荐，尤其是容量大时
      System.out.println("通过Map.entrySet遍历key和value");
      for (Map.Entry<String, String> entry : map.entrySet()) {
       System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());
      }
```

##java范型中E，T，？的区别？
自定义泛型类时，类持有者名称可以使用T(Type，一般指类) 
如果是容器的元素可以使用E(Element，一般指方法)若键值匹配可以用K(Key)和V(Value)等， 
若是<?>（一般指参数），则是默认是允许Object及其下的子类，也就是java的所有对象了。 

```
Set<T> 表示 集合里 是   T类的实例 
List<E> 表示  集合里 是  E类的实例 
List<?> 表示 集合里的对象类型不确定，未指定 
List 同 List<?> 是一样的。 
```
也就是说可以随便写咯
#WEB

##MVC
MVC本来是存在于Desktop程序中的，M是指数据模型，V是指用户界面，C则是控制器。使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。
##"GET方式提交的数据最多只能是1024字节"?  错

因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。

Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为"GET"，实质上，GET和POST只是发送机制不同，并不是一个取一个发！

##GET & POST
GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。

GET和POST是什么?HTTP协议中的两种发送请求的方法。
HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。


##GET & POST 重大区别
GET产生一个TCP数据包;POST产生两个TCP数据包。

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。

也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。

1. GET与POST都有自己的语义，不能随便混用。
2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。
3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

##PUT
在HTTP中，PUT被定义为idempotent的方法，POST则不是，这是一个很重要的区别。

PUT操作是幂等的。所谓幂等是指不管进行多少次操作，结果都一样。比如我用PUT修改一篇文章，然后在做同样的操作，每次操作后的结果并没有不同
##汽车TCP
在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。
##交通规则HTTP 
HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签(设置method为GET)，而且要求把传送的数据放在车顶上(url中)以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩;也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。

##运输公司 浏览器
不同的浏览器(发起http请求)和服务器(接受http请求)就是不同的运输公司。

虽然理论上，你可以在车顶上无限的堆货物(url中无限加参数)。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，(大多数)浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。



#MYSQL
##mysql报错

ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)

为密码错误

_:6zvQ=KtIa<
##Mysql 变量
mysql中变量不用事前申明，在用的时候直接用“@变量名”使用就可以了。

第一种用法：set @num=1; 或set @num:=1; //这里要使用变量来保存数据，直接使用@num变量
第二种用法：select @num:=1; 或 select @num:=字段名 from 表名 where ……

##Mysql为日期增加一个时间间隔：date_add()
set @dt = now();

select date_add(@dt, interval 1 day);   - 加1天

select date_add(@dt, interval 1 hour);   -加1小时

select date_add(@dt, interval 1 minute);    - 加1分钟

select date_add(@dt, interval 1 second); -加1秒

select date_add(@dt, interval 1 microsecond);-加1毫秒

select  (@dt, interval 1 week);-加1周

select date_add(@dt, interval 1 month);-加1月

select date_add(@dt, interval 1 quarter);-加1季

select date_add(@dt, interval 1 year);-加1年

###示例
MySQL adddate(), addtime()函数，可以用date_add() 来替代。下面是date_add() 实现addtime() 功能示例：

mysql> set @dt = '2009-09-09 12:12:33';

mysql>

mysql> select date_add(@dt, interval '01:15:30' hour_second);-加上1小时15分30秒

 date_add(@dt, interval '01:15:30' hour_second)

 

结果:2009-09-09 13:28:03

##Mysql 所在机器的时区影响时间函数
mysql 所在机器的时区不正确会导致  

date_add  函数失效 （计算错误）
FROM_UNIXTIME 失效 （where中使用该函数只能大于等于，不能小于）

#Docker
##批量删除已停止的容器

```
docker rm `docker ps -a |awk '{print $1}' |grep -v 64d6750891da| grep [0-9a-z]`
```
##docker 机制与原理
docker是lxc的管理器，lxc是cgroup的管理工具，cgroup是namespace的用户空间的管理接口。namespace是linux内核在task_struct中对进程组管理的基础机制。

  Linux 内核从版本 2.4.19 开始陆续引入了 namespace 的概念。其目的是将某个特定的全局系统资源（global system resource）通过抽象方法使得namespace 中的进程看起来拥有它们自己的隔离的全局系统资源实例

#折线图
打点问题，数据库group 问题，比如说14:29秒的数据每分钟聚合一次的话会 将 14：00 －14:59 秒 的数据都统计到 14:00 这个点，实际上  14：00 －14:59  的数据应该显示在15:00 这个点的。所以需要将数据库查询到的记录统一后移。




#Epp
前端启动：
client

npm install  

npm  run  local  注意配置 webpackage .env

前端打包  
cd server  
npm install 
cd ../epp-web/scripts
sh package.sh   

选择zyb 



