#琐事
##查看redhat ip

```
ip addr 
```
##查看LInux 的文件编码
```
$ file -i tivoli_eif_zyb.log
tivoli_eif_zyb.log: text/plain; charset=utf-8
```

##修改Linux 的静态ip
```
/etc/sysconfig/network-scripts/ifcfg-eth0

 BOOTPROTO=STATIC
 IPADDR=192.168.100.5
 NETMASK=255.255.255.0
 GATEWAY=192.168.100.1
 ONBOOT=yes
```
rhel7 断网 注释GATEWAY=192.168.100.1
##Linux解决Device eth0 does not seem to be present 
解决办法：

首先，打开/etc/udev/rules.d/70-persistent-net.rules内容如下面例子所示：

```
# vi /etc/udev/rules.d/70-persistent-net.rules
# This file was automatically generated by the /lib/udev/write_net_rules
# program, run by the persistent-net-generator.rules rules file.
#
# You can modify it, as long as you keep each rule on a single
# line, and change only the value of the NAME= key.
# PCI device 0x1022:0x2000 (pcnet32)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:0c:29:8f:89:9
7", ATTR{type}=="1", KERNEL=="eth*", NAME="eth0"
# PCI device 0x1022:0x2000 (pcnet32)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:0c:29:50:bd:1
7", ATTR{type}=="1", KERNEL=="eth*", NAME="eth1"

记录下，eth1网卡的mac地址00:0c:29:50:bd:17

接下来，打开/etc/sysconfig/network-scripts/ifcfg-eth0

# vi /etc/sysconfig/network-scripts/ifcfg-eth0

将 DEVICE="eth0"  改成  DEVICE="eth1"  ,
将 HWADDR="00:0c:29:8f:89:97" 改成上面的mac地址  HWADDR="00:0c:29:50:bd:17"

最后，重启网络

# service network restart
```
参考：http://www.linuxidc.com/Linux/2012-12/76248.htm

##redhat6.5修改主机名

```
vi /etc/sysconfig/network
修改HOSTNAME项
HOSTNAME=XXX
reboot
```
##linux cgroup
Linux CGroup全称Linux Control Group， 是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）

最早的名称为进程容器（process containers）。在2007年时，因为在Linux内核中，容器（container）这个名词太过广泛，为避免混乱，被重命名为cgroup，
##配置Linux 联网
编辑 /etc/resolv.conf 添加内容如下：

```
nameserver 8.8.8.8
nameserver 8.8.4.4
```
##查看Linux版本
```
uname -a 
或
cat /proc/version
或
cat /etc/redhat-release  
或 
cat /etc/issue     －－redhat 6.5 一下。
或
cat /etc/redhat-release
```
## linux 关闭防火墙

```
systemctl stop firewalld.service
systemctl disable firewalld.service	
```
### rhel 6.5 关闭防火墙
* 关闭防火墙-----service iptables stop
* 启动防火墙-----service iptables start
* 重启防火墙-----service iptables restart
* 查看防火墙状态--service iptables status
* 永久关闭防火墙--chkconfig iptables off
* 永久关闭后启用--chkconfig iptables on
* 最后两个命令同时运行，运行完成后查看防火墙关闭状态 
* service iptables status

##linux rpm包下载
http://vault.centos.org/6.3/os/x86_64/Packages/
http://rpm.pbone.net/index.php3

##rpm 包命令
```
安装rpm  
rpm -ivh

--force 参数为重复替换
--nodeps 参数为强制安装，忽略依赖

列出rpm包的内容：
rpm -qpl *.rpm

解压rpm包的内容：（没有安装，就像解压tgz包一样rpm包）
rpm2cpio *.rpm | cpio -div

删除rpm包 
rpm -e <包的名字>
```
##linux 修改时区
1. 执行tzselect命令-->选择Asia-->选择China-->选择east China - Beijing, Guangdong, Shanghai, etc-->然后输入1

	如果不想用tzselect命令，可以修改文件变更时区。  vi /etc/sysconfig/clock  

	```
	ZONE=Asia/Shanghai（查/usr/share/zoneinfo下面的文件） 
	UTC=false 
	ARC=false
	```
2. rm /etc/localtime3、链接到上海时区文件       
3. ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime  重启机器

##Linux 修改时间
date -s "2017-06-15 09:55:25"
date -s "09:55:25"
##Redhat7.1
vi /etc/hostname
hostnamectl set-hostname your_hostname 
修改 redhat 7.1 的hostname

#shell
eval命令将会首先扫描命令行进行所有的替换，憨厚再执行命令。
##shell生成随机数
生成1-60 的随机数

```
 #!/bin/bash
 
 echo "$((($RANDOM)%60))"
```
##判断上一条命令是否执行成功
```
if [ $? -eq 0 ];
then
	echo "执行成功";
else
	echo "执行失败";
fi
```
##shell 判断

```
#!/bin/sh
myPath="/var/log/httpd/"
myFile="/var /log/httpd/access.log"

# 这里的-x 参数判断$myPath是否存在并且是否具有可执行权限
if [ ! -x "$myPath"]; then
 mkdir "$myPath"
fi
# 这里的-d 参数判断$myPath是否是一个目录
if [ ! -d "$myPath"]; then
 mkdir "$myPath"
fi

# 这里的-f参数判断$myFile 文件是否存在
if [ ! -f "$myFile" ]; then
 touch "$myFile"
fi

# 这里的-s参数判断$myFile 判断文件存在且非空 
if [ ! -s "$myFile" ]; then
 touch "$myFile"
fi

# 其他参数还有-n,-n是判断一个变量是否是否有值 如果string 非空(非0），返回0(true)  
if [ ! -n "$myVar" ]; then
 echo "$myVar is empty"
 exit 0
fi

# 这里的-z 参数判断$myPath是否为空
if [ ! -z "$myPath"]; then
 mkdir "$myPath"
fi

# 两个变量判断是否相等
if [ "$var1" = "$var2" ]; then
 echo '$var1 eq $var2'
else
 echo '$var1 not eq $var2'
fi



#-eq  -ne  -lt  -nt只能用于整数，不适用于字符串，字符串等于用赋值号=
if [ int1 -eq int2 ]    如果int1等于int2   
if [ int1 -ne int2 ]    如果不等于    
if [ int1 -ge int2 ]       如果>=
if [ int1 -gt int2 ]       如果>
if [ int1 -le int2 ]       如果<=
if [ int1 -lt int2 ]       如果<

```
##!/bin/sh 与 !/bin/bash
/bin/sh 与 /bin/bash 虽然大体上没什么区别, 但仍存在不同的标准. 标记为 “#!/bin/sh” 的脚本不应使用任何 POSIX 没有规定的特性 (如 let 等命令, 但 “#!/bin/bash” 可以). Debian 曾经采用 /bin/bash 更改 /bin/dash，目的使用更少的磁盘空间、提供较少的功能、获取更快的速度。但是后来经过 shell 脚本测试存在运行问题。因为原先在 bash shell 下可以运行的 shell script (shell 脚本)，在 /bin/sh 下还是会出现一些意想不到的问题，不是100%的兼用。
##从终端读取参数
-t 30 等待30s

-p "The para is params "  // 提示信息

```
#!/bin/sh
params=0;
#Read the params . Set The finalEnv. Pay Attention 'read' NOT 'Read'
read -t 30 -p "The para is params " params ;
echo "$params"
```
##从配置文件中读取数据
env.properties

```
flume_path=/opt/apps/wh.agent/current
epp_path=/opt/apps/epp_manager

prop_package=epp-manager
prop_appRoot=/opt/apps
```
注意：参数名不要用点隔开，应用下划线。 //test.sh

```
#!/bin/sh
. env.properties
finalPackage=${flume_path}
echo "$finalPackage"
```
##从配置文件中读取（二）

```
	VALUES=`grep "^flume_path" env.properties|grep -v \# |cut -d'=' -f2`;

```
通过查询的方式获取参数 ，^ 以此为开头。 grep -v \# 忽略以＃开头的记录
##数组

```
#declare -a: define an array
#declare -i: define an integer
declare -i index=1
declare -a envMap
declare -a formatMap=(["1"]="docker" ["2"]="springboot")


#scan the env  all dir to envMap
for i in env/* ; do 
 if [ -d ${i} ]; then
	envMap["${index}"]="`basename ${i}`"
	index=index+1
 fi
done

#使用@ 或 * 可以获取数组中的所有元素
#print envMap all element
for i in ${!envMap[@]} ;do
	echo [${i}]:${envMap[${i}]}
done

```
##shell运算符

```
==	相等。用于比较两个数字，相同则返回 true。	[ $a == $b ] 返回 false。

-eq	检测两个数是否相等，相等返回 true。	[ $a -eq $b ] 返回 false。

=	检测两个字符串是否相等，相等返回 true。	[ $a = $b ] 返回 false。

!=	检测两个字符串是否相等，不相等返回 true。	[ $a != $b ] 返回 true。

-z	检测字符串长度是否为0，为0返回 true。	[ -z $a ] 返回 false。

-n	检测字符串长度是否为0，不为0返回 true。	[ -n $a ] 返回 true。

-d file	检测文件是否是目录，如果是，则返回 true。	[ -d $file ] 返回 false。

-f file	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。	[ -f $file ] 返回 true。
```
##egrep
Linux egrep命令用于在文件内查找指定的字符串。
egrep执行效果与"grep-E"相似，使用的语法及参数可参照grep指令，与grep的不同点在于解读字符串的方法。
egrep是用extended regular expression语法来解读的，而grep则用basic regular expression 语法解读，extended regular expression比basic regular expression的表达更规范。

```
egrep [范本模式] [文件或目录] 
egrep Linux * 
 //查找当前目录下所有文件中包含字符串"Linux"的文件
```
##echo -e
```
echo -e "OK! \n" # -e 开启转义

echo "$NAME"   #此时 $NAME 取变量值
echo '$NAME'  #此时把$NAME 当作字符串输出
echo '"$NAME"'  #此时把$NAME 当作字符串输出

```
##sed -i
Linux sed命令是利用script来处理文本文件。
sed可依照script的指令，来处理、编辑文本文件。
Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。

####选项与参数：

* -n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。
* -e ：直接在命令列模式上进行 sed 的动作编辑；
* -f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；
* -r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)
* -i ：直接修改读取的文件内容，而不是输出到终端。

####function：

* a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
* c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
* d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
* i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
* p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
* s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！

```
sed -i 's/原字符串/新字符串/' /home/1.txt
sed -i 's/原字符串/新字符串/g' /home/1.txt
#原串支持正则匹配哦。 ？ 为sed 的分隔符 # 和 / 也可以作为 sed 命令的分隔符
sed -i 's?^db.jdbc.url=.*?db.jdbc.url='$url'?' ../conf/application.properties;
```

##sh -c  "。。。"
从String中读取命令 并处理他们
##curl 
-d 传递参数 -o将输出重定向到一个文件（多用于下载文件）-s curl 在安静模式下执行，不会发送任何数据到stdout
```
curl -d "status=pedding" -o /dev/null -s $URL
```

##redhat ssh免密登录
B 机的.ssh 文件夹要是 通过 ssh-keygen -t rsa 命令创建的，因为redhat 的 ssh 文件夹用命令生成的，和手动生成的权限不一样。所以ssh 免密登录时有坑

```
在B机之行
ssh-keygen -t rsa
cp id_rsa.pub authorized_keys

拷贝A 机的 id_rsa.pub 到B机的authorized_keys 中
此时可以从A 机免密登录B机
```

#java

##java 字符串判断
判断某字符串是否为空或长度为0或由空白符(whitespace)构成
下面是示例：

```
StringUtils.isBlank(null) = true
StringUtils.isBlank("") = true
StringUtils.isBlank(" ") = true
StringUtils.isBlank(" ") = true
StringUtils.isBlank("\t \n \f \r") = true //对于制表符、换行符、换页符和回车符StringUtils.isBlank()均识为空白符
StringUtils.isBlank("\b") = false //"\b"为单词边界符
StringUtils.isBlank("bob") = false
StringUtils.isBlank(" bob ") = false
```
2.public static boolean isEmpty(String str)
判断某字符串是否为空，为空的标准是str==null或str.length()==0
下面是StringUtils判断是否为空的示例：

```
StringUtils.isEmpty(null) = true
StringUtils.isEmpty("") = true
StringUtils.isEmpty(" ") = false //注意在StringUtils中空格作非空处理
StringUtils.isEmpty(" ") = false
StringUtils.isEmpty("bob") = false
StringUtils.isEmpty(" bob ") = false
```
##spring4 时间

```
//使用瞬时时间 + 时区  
Instant instant = Instant.now();  
LocalDateTime d3 = LocalDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());  
System.out.println(d3);  
```

##jvm内存
* JDK1.7后，常量池被放入到堆空间中。方法是放在栈里面的。
* 从栈内存里面去数据要快一些。
* JVM有两类存储区：常量缓冲池和方法区
* 常量缓冲池用于存储类名称、方法和字段名称以及字符串常量。
方法区则用于存储Java方法的字节码。

##intern()
* intern()方法设计的初衷，就是重用String对象，以节省内存消耗。
* 使用intern() 方法创建字符串，当常量池中已经包含一个等于此 String 对象的字符串（用 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并返回此 String 对象的引用。 

##replace和replaceAll的区别
* 1)replace的参数是char和CharSequence，即可以支持字符的替换，也支持字符串的替换(CharSequence即字符串序列的意思,说白了也就是字符串)；
* 2)replaceAll的参数是regex，即基于规则表达式的替换，比如，可以通过replaceAll("\\d", "*")把一个字符串所有的数字字符都换成星号;
* 相同点：都是全部替换，即把源字符串中的某一字符或字符串全部换成指定的字符或字符串，如果只想替换第一次出现的，可以使用replaceFirst()，这个方法也是基于规则表达式的替换，但与replaceAll()不同的是，只替换第一次出现的字符串；
* 另外，如果replaceAll()和replaceFirst()所用的参数据不是基于规则表达式的，则与replace()替换字符串的效果是一样的，即这两者也支持字符串的操作；
* 还有一点注意:：执行了替换操作后,源字符串的内容是没有发生改变的。

##StringBuilder & StringBuffer
* StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。
* String类是不可变类，任何对String的改变都 会引发新的String对象的生成(除了intern())；StringBuffer则是可变类，任何对它所指代的字符串的改变都不会产生新的对象。

##java 基本数据类型
又称为原始数据类型byte,short,char,int,long,float,double,boolean，他们之间的比较应该使用（==），比较的是他们的值。
##java  复合数据类型
当复合数据类型用（==）进行比较，比较的是他们在内存中的存放地址。
当复合数据类型之间进行equals比较时，这个方法的初始行为是比较对象在堆内存中的地址，但在一些诸如String,Integer,Date类中把Object中的这个方法覆盖了，作用被覆盖为比较内容是否相同。
##TreeMap和HashMap
* HashMap：适用于在Map中插入、删除和定位元素。 
* Treemap：适用于按自然顺序或自定义顺序遍历键(key)。 
* HashMap通常比TreeMap快一点(树和哈希表的数据结构使然)，建议多使用HashMap，在需要排序的Map时候才用TreeMap。 
###Treemap
Treemap的实现是红黑树算法的实现，红黑树是一颗自平衡的排序二叉树；对红黑二叉树而言它主要包括三大基本操作：左旋、右旋、着色。
一棵有效的红黑树二叉树而言我们必须增加如下规则：
       * 1、每个节点都只能是红色或者黑色
       * 2、根节点是黑色
       * 3、每个叶节点（NIL节点，空节点）是黑色的。
       * 4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。
       * 5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

##HashMap
当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry
####当两个对象的hashcode相同会发生什么？
因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。
####如果两个键的hashcode相同，你如何获取值对象？
当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象，如果有两个值对象储存在同一个bucket，找到bucket位置之后，将会遍历链表直到找到值对象，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。

####如何减少碰撞的发生
使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。
####如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？
默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。

####重新调整HashMap大小存在什么问题吗？
当重新调整HashMap大小的时候，**存在条件竞争**，因为如果两个线程都发现HashMap需要重新调整大小了（多线程建议使用ConcurrentHashMap），它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。
####为什么String, Interger这样的wrapper类适合作为键？
而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。
####我们可以使用自定义的对象作为键吗？
当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。
####我们可以使用CocurrentHashMap来代替Hashtable吗
ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性
##HashMap和Hashtable
* HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)
* HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。

##什么是HashSet

HashSet实现了Set接口，它不允许集合中有重复的值，当我们提到HashSet时，第一件事情就是在将对象存储在HashSet之前，要先确保对象重写equals()和hashCode()方法，这样才能比较对象的值是否相等，以确保set中没有储存相等的对象。如果我们没有重写这两个方法，将会使用这个方法的默认实现。

HashSet使用**成员对象**来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false

public boolean add(Object o)方法用来在Set中添加元素，当元素值重复时则会立即返回false，如果成功添加的话会返回true。

##ConcurrentHashMap
数据结构 ConcurrentHashMap的目标是实现支持高并发、高吞吐量的线程安全的HashMap

一个ConcurrentHashMap由多个segment组成，每一个segment都包含了一个HashEntry数组的hashtable， 每一个segment包含了对自己的hashtable的操作，比如get，put，replace等操作，这些操作发生的时候，对自己的hashtable进行锁定。由于每一个segment写操作只锁定自己的hashtable，所以可能存在多个线程同时写的情况，性能无疑好于只有一个hashtable锁定的情况。

ConcurrentHashMap具体是线程安全的.它引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。
在ConcurrentHashMap中，就是把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中


       
##Map.Entry
Map是java中的接口，Map.Entry是Map的一个内部接口。

Map提供了一些常用方法，如keySet()、entrySet()等方法，keySet()方法返回值是Map中key值的集合；entrySet()的返回值也是返回一个Set集合，此集合的类型为Map.Entry。

Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry<K,V>。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue方法。

###Map.Entry使用

你是否已经对每次从Map中取得关键字然后再取得相应的值感觉厌倦？使用Map.Entry类，你可以得到在同一时间得到所有的信息。

```
 //第三种：推荐，尤其是容量大时
      System.out.println("通过Map.entrySet遍历key和value");
      for (Map.Entry<String, String> entry : map.entrySet()) {
       System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());
      }
```

##java范型中E，T，？的区别？
自定义泛型类时，类持有者名称可以使用T(Type，一般指类) 超类

如果是容器的元素可以使用E(Element，一般指方法)若键值匹配可以用K(Key)和V(Value)等， 

若是<?>（一般指参数），则是默认是允许Object及其下的子类，也就是java的所有对象了。 

```
Set<T> 表示 集合里 是   T类的实例 
List<E> 表示  集合里 是  E类的实例 
List<?> 表示 集合里的对象类型不确定，未指定 
List 同 List<?> 是一样的。 
```
也就是说可以随便写咯

##Integer.valueof(String s)和Integer.parseInt(String s)的具体区别
Integer.valueof(String s)是将一个包装类,是一个实际值为数字的变量先转成string型再将它转成Integer型的包装类对象(相当于转成了int的对象)这样转完的对象就具有方法和属性了。
而Integer.parseInt(String s)只是将是数字的字符串转成数字，注意他返回的是int型变量不具备方法和属性。

设有下面两个赋值语句：
a=Integer.parseInt(“123”);
b=Integer.valueOf(“123”).intValue();
下述说法正确的是（d）。
A、a是整数类型变量，b是整数类对象。
B、a是整数类对象，b是整数类型变量。
C、a和b都是整数类对象并且值相等。
D、a和b都是整数类型变量并且值相等。

###解释：

parseInt(Strings)方法是类Integer的静态方法，它的作用就是将形参s转化为整数，比如：

```
Interger.parseInt("1")=1;
Integer.parseInt("20")=20;
Integer.parseInt("324")=324;
```
当然，s表示的整数必须合法，不然是会抛异常的。
valueOf(Strings)也是Integer类的静态方法，它的作用是将形参s转化为Integer对象，
什么是Integer对象，Integer就是基本数据类型int型包装类，就是将int包装成一个类，这样在很多场合下是必须的。如果理解不了，你就认为int是Integer的mini版，好用了很多，但也丢失了一些功能，好了，看代码：
Interger.valueOf("123")=Integer(123)
这时候Integer（123）就是整数123的对象表示形式，它再调用intValue()方法，就是将123的对象表示形式转化为基本数据123
所以，选择D

##Long和long区别
Long类型与long类型的区别导致的。Long类型变量表示的是一个对象，其值是对象的一个属性。相当于一个Long变量中包含了一个long类型的值。所以当进行两个Long类型变量比较时如果用的是==来比较，那么实际比较的是两个Long型变量指向的对象的地址，显然两个不同Long对象地址是不同的。

通过Long类型的equals方法来比较对象的值。equals方法是获取Long类型存储的值和其他Long对象或者值进行比较。如果equals的参数是Long类型，那么会取得参数的值与调用的对象的值进行比较，进而得出符合我们预期的结果

##值传递和引用传递
* 基本类型(byte--short--int--long--float--double--boolean--char)的变量总是按值传递
* 就对象而言，不是将对象本身传递给方法，而是将对象的的引用或者说对象的首地址传递给方法；引用本身是按值传递的，通过对象的引用，方法可以直接操作该对象
* 如果传递的是数组的引用，则对数组元素的后续修改可以在原始数组中反映出来（因为数组本身就是个对象，int[] a = new int[2];，这里面的int是数组元素的类型，而数组元素的修改是操作对象）


##spring
###IOC

学 java 的人应该都知道spring，学spring的人呢都应该知道 IOC和 AOP 对吧。今天就简单的说一下spring 的IOC。

控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法。
其实spring就是一个容器，一个bean容器。主要是完成了完成对象的创建和依赖的管理注入。
###什么是控制反转呢？
所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给ioc容器来帮忙实现，也就是 ioc 容器帮我们做了原本应该我门自己实现的对象创建和依赖的内容。
好了那么ioc 容器是怎么帮我门创建 对象 和注入依赖呢？
1。读取xml
2。反射




ioc 控制反转 也称为 DI （dependenty injection 依赖注入）
优点：
spring 帮我们管理和创建对象，降低了耦合性。
通过xml 文件配置方便修改 灵活。
 
反转： 反转到容器控制，本来是要由我控制的现在交给容器帮忙控制，容器里面各种对象，相互之间各种依赖，随意装配 。 

spring ioc 帮我们创建和管理了我们需要创建的对象，并像搭乐高积木一样，来管理这个对象间的关系。

Spring Bean的创建是典型的工厂模式，bean 的生命周期默认是单例模式
##AOP
面向切面编程
AOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。
动态代理就是生成一个代理对象，对代理需要被代理的对象。 代理对象 是为了 代理被代理对象创建的对象。

面线切面编程就像是横着切了一刀。 使用场景 权限、日志、事务（start ，commit）、异常处理、

http://blog.csdn.net/moreevan/article/details/11977115/
http://www.cnblogs.com/hongwz/p/5764917.html
https://www.zhihu.com/question/24863332

如果你的类没有实现接口，spring 也能给你生成动态代理，spring直接生成二进制码，用继承。 

aspectj 是一个专门用来生成代理的框架
joinpoint 切入点 ；语法 ：execution(public void com.abel.dao.impl.UserDAOImpl.save(com.abel.model.User )
pointcut 连接点的集合 pointcut 是 joinpoint 的集合
语法 ：execution(* com.abel.dao.impl.*.*(..)
com.abel.dao.impl 路径下的所有类的（任何返回值）
所有方法

Aspect 就是切面类
advice @Befor 
target 代理对象
weave  织入


<aop:after> 后通知
<aop:after-returning> 返回后通知
<aop:after-throwing> 抛出后通知
<aop:around> 周围通知
<aop:aspect>定义一个切面
<aop:before>前通知

1. 引入包

# spring 注入接口
当接口中有范型的时候想当于多个 接口，此时注入接口报错
当接口多个实现类时，此时注入接口，报错。


##gradle
Gradle和Maven都是项目自动构建工具，编译源代码只是整个过程的一个方面.虽然两者都是项目工具，但是maven现在已经是行业标准，Gradle是后起之秀，Gradle抛弃了Maven的基于XML的繁琐配置，众所周知XML的阅读体验比较差，对于机器来说虽然容易识别，但毕竟是由人去维护的。取而代之的是Gradle采用了领域特定语言Groovy的配置，大大简化了构建代码的行数.

Gradle给我最大的有点是两点。其一是简洁，基于Groovy的紧凑脚本实在让人爱不释手，在表述意图方面也没有什么不清晰的地方。其二是灵活，各种在Maven中难以下手的事情，在Gradle就是小菜一碟，比如修改现有的构建生命周期，几行配置就完成了，同样的事情，在Maven中你必须编写一个插件，

范例 用 gradle 引入依赖

```
dependencies {
    compile('org.springframework:spring-core:2.5.6')
    compile('org.springframework:spring-beans:2.5.6')
    compile('org.springframework:spring-context:2.5.6')
    compile('com.google.code.kaptcha:kaptcha:2.3:jdk15')
    testCompile('junit:junit:4.7')
}
```


#WEB

##MVC
MVC本来是存在于Desktop程序中的，M是指数据模型，V是指用户界面，C则是控制器。使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。
##"GET方式提交的数据最多只能是1024字节"?  错

因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。

Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为"GET"，实质上，GET和POST只是发送机制不同，并不是一个取一个发！

##GET & POST
GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。

GET和POST是什么?HTTP协议中的两种发送请求的方法。
HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。


##GET & POST 重大区别
GET产生一个TCP数据包;POST产生两个TCP数据包。

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。

也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。

1. GET与POST都有自己的语义，不能随便混用。
2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。
3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

##PUT
在HTTP中，PUT被定义为idempotent的方法，POST则不是，这是一个很重要的区别。

PUT操作是幂等的。所谓幂等是指不管进行多少次操作，结果都一样。比如我用PUT修改一篇文章，然后在做同样的操作，每次操作后的结果并没有不同
##汽车TCP
在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。
##交通规则HTTP 
HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签(设置method为GET)，而且要求把传送的数据放在车顶上(url中)以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩;也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。

##运输公司 浏览器
不同的浏览器(发起http请求)和服务器(接受http请求)就是不同的运输公司。

虽然理论上，你可以在车顶上无限的堆货物(url中无限加参数)。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，(大多数)浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。

##Https
HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。


超文本传输协议 (HTTP-Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。


##http和https区别
https协议需要到ca申请证书，一般免费证书很少，需要交费。http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。http的连接很简单,是无状态的HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、

http的连接很简单,是无状态的。HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全

#java多线程
##产生线程不安全的原因

在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。
##竞态条件 & 临界区
当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作**临界区**。上例中add()方法就是一个临界区,它会产生**竞态条件**。在临界区中使用适当的同步就可以避免竞态条件。
##共享资源
允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件。当多个线程同时更新共享资源时会引发竞态条件。
##局部变量
局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享。所以，基础类型的局部变量是线程安全的。

```
public void someMethod(){
  long threadSafeInt = 0;//局部变量
  threadSafeInt++;
}
```
##局部的对象引用
上面提到的局部变量是一个基本类型，如果局部变量是一个**对象类型**呢？对象的局部引用和基础类型的局部变量不太一样。尽管引用本身没有被共享，但引用所指的对象并没有存储在线程的栈内，**所有的对象都存在共享堆**中，所以对于局部对象的引用，有可能是线程安全的，也有可能是线程不安全的。

如果在某个方法中创建的对象不会被其他方法或全局变量获得，或者说方法中创建的对象没有逃出此方法的范围，那么它就是**线程安全**的。实际上，哪怕将这个对象作为参数传给其它方法，只要**别的线程获取不到这个对象**，那它仍是线程安全的。

```
public void someMethod(){
  LocalObject localObject = new LocalObject();
  localObject.callMethod();
  method2(localObject);
}

public void method2(LocalObject localObject){
  localObject.setValue("value");
}
```
上面样例中 LocalObject 对象没有被方法返回，也没有被传递给someMethod()方法外的对象，始终在someMethod()方法内部。**每个执行someMethod()的线程都会创建自己的LocalObject对象**，并赋值给localObject引用。因此，这里的LocalObject是线程安全的。事实上，整个someMethod()都是线程安全的。即使将LocalObject作为参数传给同一个类的其它方法或其它类的方法时，它仍然是**线程安全**的。当然，如果LocalObject通过某些方法被传给了别的线程，那它就不再是线程安全的了。
	
```
如果一个资源的创建，使用，销毁都在同一个线程内完成，且永
远不会脱离该线程的控制，则该资源的使用就是线程安全的。
```
##Java中实现线程安全的方法
* 最简单的方式，使用Synchronization关键字:
http://blog.csdn.net/suifeng3051/article/details/48711405
* 使用java.util.concurrent.atomic 包中的原子类，例如 AtomicInteger
* 使用java.util.concurrent.locks 包中的锁
* 使用线程安全的集合ConcurrentHashMap
* 使用volatile关键字，保证变量可见性（直接从内存读，而不是从线程cache读）

http://blog.csdn.net/suifeng3051/article/details/52164267
##java线程池
###ExecutorService的创建
* Executors.newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
* Executors.newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
* Executors.newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
* Executors.newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

备注：Executors只是一个工厂类，它所有的方法返回的都是ThreadPoolExecutor、ScheduledThreadPoolExecutor这两个类的实例。


###ExecutorService有如下几个执行方法
- executorService.execute(Runnable);这个方法接收一个Runnable实例，并且异步的执行
- executorService.submit(Runnable)
- executorService.submit(Callable)
- executorService.invokeAny(...)
- executorService.invokeAll(...)

###execute(Runnable)
这个方法接收一个Runnable实例，并且异步的执行

```
executorService.execute(new Runnable() {
public void run() {
    System.out.println("Asynchronous task");
}
});

executorService.shutdown();
```
###submit(Runnable)
submit(Runnable)和execute(Runnable)区别是前者可以返回一个Future对象，通过返回的Future对象，我们可以检查提交的任务是否执行完毕，请看下面执行的例子：

```
Future future = executorService.submit(new Runnable() {
public void run() {
    System.out.println("Asynchronous task");
}
});

future.get();  //returns null if the task has finished correctly.

```
###submit(Callable)
submit(Callable)和submit(Runnable)类似，也会返回一个Future对象，但是除此之外，submit(Callable)接收的是一个Callable的实现，Callable接口中的call()方法有一个返回值，可以返回任务的执行结果，而Runnable接口中的run()方法是void的，没有返回值。请看下面实例：

```
Future future = executorService.submit(new Callable(){
public Object call() throws Exception {
    System.out.println("Asynchronous Callable");
    return "Callable Result";
}
});

System.out.println("future.get() = " + future.get());
```
如果任务执行完成，future.get()方法会返回Callable任务的执行结果。注意，future.get()方法会产生阻塞。
###invokeAny(…)
invokeAny(...)方法接收的是一个Callable的集合，执行这个方法不会返回Future，但是会返回所有Callable任务中其中一个任务的执行结果。这个方法也无法保证返回的是哪个任务的执行结果，反正是其中的某一个。

```
ExecutorService executorService = Executors.newSingleThreadExecutor();

Set<Callable<String>> callables = new HashSet<Callable<String>>();

callables.add(new Callable<String>() {
public String call() throws Exception {
    return "Task 1";
}
});
callables.add(new Callable<String>() {
public String call() throws Exception {
    return "Task 2";
}
});
callables.add(new Callable<String>() {
    public String call() throws Exception {
    return "Task 3";
}
});

String result = executorService.invokeAny(callables);
System.out.println("result = " + result);
executorService.shutdown();
```
###invokeAll(…)
invokeAll(...)与 invokeAny(...)类似也是接收一个Callable集合，但是前者执行之后会返回一个Future的List，其中对应着每个Callable任务执行后的Future对象。

```
List<Future<String>> futures = executorService.invokeAll(callables);

for(Future<String> future : futures){
System.out.println("future.get = " + future.get());
}

executorService.shutdown();
```
#MYSQL
##mysql报错

ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)

为密码错误

_:6zvQ=KtIa<
##Mysql 变量
mysql中变量不用事前申明，在用的时候直接用“@变量名”使用就可以了。

第一种用法：set @num=1; 或set @num:=1; //这里要使用变量来保存数据，直接使用@num变量
第二种用法：select @num:=1; 或 select @num:=字段名 from 表名 where ……

##Mysql为日期增加一个时间间隔：date_add()
set @dt = now();

select date_add(@dt, interval 1 day);   - 加1天

select date_add(@dt, interval 1 hour);   -加1小时

select date_add(@dt, interval 1 minute);    - 加1分钟

select date_add(@dt, interval 1 second); -加1秒

select date_add(@dt, interval 1 microsecond);-加1毫秒

select  (@dt, interval 1 week);-加1周

select date_add(@dt, interval 1 month);-加1月

select date_add(@dt, interval 1 quarter);-加1季

select date_add(@dt, interval 1 year);-加1年

###示例
MySQL adddate(), addtime()函数，可以用date_add() 来替代。下面是date_add() 实现addtime() 功能示例：

mysql> set @dt = '2009-09-09 12:12:33';

mysql>

mysql> select date_add(@dt, interval '01:15:30' hour_second);-加上1小时15分30秒

 date_add(@dt, interval '01:15:30' hour_second)

 

结果:2009-09-09 13:28:03

##Mysql 所在机器的时区影响时间函数
mysql 所在机器的时区不正确会导致  

date_add  函数失效 （计算错误）
FROM_UNIXTIME 失效 （where中使用该函数只能大于等于，不能小于）
##mysql 使用正则
mysql sql 语句使用 REGEXP (正则匹配关键字)需要在 数据库连接字符串中添加如下配置

```
&useUnicode=true&characterEncoding=UTF-8
```

#oracle
打开cmd输入sqlplus

```
sqlplus
sys/manager as sysdba，以超级管理员的权限登录数据库
create user c##用户名 identified by 密码; 
授权
为刚创建的用户解锁：alter user c##用户名 account unlock;
授予新用户创建权限：grant create session to  c##用户名 ;
授予新用户数据库管理员权限：grant dba to c##用户名;
授予用户其它权限：
   GRANT CREATE USER,DROP USER,ALTER USER ,
            CREATE  ANY  VIEW , DROP ANY VIEW,
            EXP_FULL_DATABASE,IMP_FULL_DATABASE, 
            DBA,CONNECT,RESOURCE,CREATE SESSION  TO  c##用户名;  

```
到此，用户就创建成功了，到https://localhost:5500/em登录试试，登录成功。不过不能以管理员权限登录。 不用输入容器名

打开监控链接
https://jingyan.baidu.com/article/03b2f78c7a0ab75ea237ae33.html
##注意
oracle中 表名和 字段需要加 "" 
```
SELECT * from "person" where "create_time" > to_date('2017-10-25 11:45:20','yyyy-mm-dd HH:mi:ss');
```
##为什么需要MyCat？

虽然云计算时代，传统数据库存在着先天性的弊端，但是NoSQL数据库又无法将其替代。如果传统数据易于扩展，可切分，就可以避免单机（单库）的性能缺陷。

MyCat的目标就是：低成本地将现有的单机数据库和应用平滑迁移到“云”端，解决数据存储和业务规模迅速增长情况下的数据瓶颈问题。2014年MyCat首次在上海的《中华架构师》大会上对外宣讲引发围观，更多的人参与进来，随后越来越多的项目采用了MyCat。

MyCat截至到2015年4月，保守估计已经有超过60个项目在使用，主要应用在电信领域、互联网项目，大部分是交易和管理系统，少量是信息系统。比较大的系统中，数据规模单表单月30亿。

##MyCat是什么？

从定义和分类来看，它是一个开源的分布式数据库系统，是一个实现了MySQL协议的服务器，前端用户可以把它看作是一个数据库代理，用MySQL客户端工具和命令行访问，而其后端可以用MySQL原生协议与多个MySQL服务器通信，也可以用JDBC协议与大多数主流数据库服务器通信，其核心功能是分表分库，即将一个大表水平分割为N个小表，存储在后端MySQL服务器里或者其他数据库里。

MyCat发展到目前的版本，已经不是一个单纯的MySQL代理了，它的后端可以支持MySQL、SQL Server、Oracle、DB2、PostgreSQL等主流数据库，也支持MongoDB这种新型NoSQL方式的存储，未来还会支持更多类型的存储。而在最终用户看来，无论是那种存储方式，在MyCat里，都是一个传统的数据库表，支持标准的SQL语句进行数据的操作，这样一来，对前端业务系统来说，可以大幅降低开发难度，提升开发速度

#Docker
##批量删除已停止的容器

```
docker rm `docker ps -a |awk '{print $1}' |grep -v 1c3e744ba21d| grep [0-9a-z]`
```
##docker 机制与原理
docker是lxc的管理器，lxc是cgroup的管理工具，cgroup是namespace的用户空间的管理接口。namespace是linux内核在task_struct中对进程组管理的基础机制。

  Linux 内核从版本 2.4.19 开始陆续引入了 namespace 的概念。其目的是将某个特定的全局系统资源（global system resource）通过抽象方法使得namespace 中的进程看起来拥有它们自己的隔离的全局系统资源实例

#折线图
打点问题，数据库group 问题，比如说14:29秒的数据每分钟聚合一次的话会 将 14：00 －14:59 秒 的数据都统计到 14:00 这个点，实际上  14：00 －14:59  的数据应该显示在15:00 这个点的。所以需要将数据库查询到的记录统一后移。

#mybatis
nternal error : nested exception is org.apache.ibatis.reflection.ReflectionException: There is no getter for property named 'langId' in 'class java.lang.Integer'

mybatis 有内置对象 _parameter ，对于单个参数的判断应该用 _parameter 代代替 例如：

```
<select id="getUsersWithOnLine" parameterType="int" resultMap="userMap">
		SELECT u.* FROM user u
		<where>
			<if test="_parameter != null">
				u.status != #{status}
			</if>
		</where>
	</select>
```



#设计模式
##中介者模式
是为了降低耦合，遵守迪米特法则


##树状结构 mysql 查询
树状应该记录 父节点 和 子节点，然后循环递归查询。

将查询结果映射到java bean ，java bean应该 也是 嵌套设计
这样就可以将查询出来的 树 映射出来

```
public class Tree {
	private Integer id;
	private String description;
	private String severity;
	private List<Tree> childTree;
```
 
使用mysql 函数

```
DROP FUNCTION IF EXISTS getSituationTreeLst;  

delimiter //
CREATE FUNCTION `getSituationTreeLst`(rootId INT)
	RETURNS varchar(1000)
    BEGIN
    DECLARE sTemp VARCHAR(1000);
    DECLARE sTempChd VARCHAR(1000);
		SET sTemp = '$';
		SET sTempChd = cast(rootId as CHAR);
		WHILE sTempChd is not null DO
			SET sTemp = concat(sTemp,',',sTempChd);
			
			SELECT
		group_concat(s2.id)  INTO sTempChd
		FROM
			situation s2
		WHERE
			FIND_IN_SET(sTempChd , s2.story)
		END WHILE;
		RETURN sTemp;
END //
``` 


#编码
##UTF-8
UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，又称万国码。

 为了提高Unicode的编码效率，于是就出现了UTF-8编码。UTF-8可以根据不同的符号自动选择编码的长短。比如英文字母可以只用1个字节就够了。
 
 mysql支持的 utf8 编码最大字符长度为 3 字节，如果遇到 4 字节的宽字符就会插入异常了
 
 
##超集
 如果一个集合S2中的每一个元素都在集合S1中，且集合S1中可能包含S2中没有的元素，则集合S1就是S2的一个超集，反过来，S2是S1的子集。 S1是S2的超集，若S1中一定有S2中没有的元素，则S1是S2的真超集，反过来S2是S1的真子集。



#算法
##排序算法的稳定性？
排序算法可以根据稳定性分为两种：稳定和非稳定算法。那么怎么区分它们？

如果链表中存在两个相同元素，稳定排序算法可以在排序之后保持他两原来的次序，而非稳定性的则不能保证

##简单排序类别

有两种简单排序算法分别是插入排序和选择排序，两个都是数据量小时效率高。实际中插入排序一般快于选择排序，由于更少的比较和在有差不多有序的集合表现更好的性能。但是选择排序用到更少的写操作，所以当写操作是一个限制因素时它被使用到。




##希尔排序的时间性能优于直接插入排序的原因：
当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。
当n值较小时，n和n2的差别也较小，即直接插入排序的最好时间复杂度O(n)和最坏时间复杂度0(n2)差别不大。
在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但由于已经按di-1作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。



##插入排序与选择排序的区别

插入排序类似于选择排序，不同之处是插入排序是一个元素一个元素地往有序序列中插入，而选择排序则是在无序序列中选择最大(最小)元素放入有序队列末尾。一个主要操作有序队列，一个则是无序队列。这样就导致选择排序每次都要遍历一次无序队列，而插入排序则不需要遍历整个有序队列，只需要遍历到该元素应有的位置即可，这样就使得基本有序的队列的复杂度为O(n).
但同时这会导致插入排序用到更多的写操作，因为内部循环时他对数组进行大量的移位操作，大家知道移位操作对于数组是非常低效率的。而选择排序因为每次添加元素都是添加在末尾，所以不需要移位操作

##为什么梳排序和希尔排序都可以通过分组来提高效率呢？
因为插入排序和冒泡排序有几个相似的点：1.当文件初态基本有序时时间复杂度为O(n). 2.数据量小时效率更好，因为最好情况n和最坏情况n^2相差不大。


##归并
分治法 先"分割"再"合并"







#堆、栈、堆栈、队列
##堆：
###什么是堆？又该怎么理解呢？
* ①堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：
   ·堆中某个节点的值总是不大于或不小于其父节点的值；
   ·堆总是一棵完全二叉树。
将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。
* ②堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。
* ③堆是应用程序在运行的时候请求操作系统分配给自己内存，一般是申请/给予的过程。
* ④堆是指程序运行时申请的动态内存，而栈只是指一种使用堆的方法(即先进后出)。
父节点比子节点大的称为最大堆：
父节点比子节点小的为最小堆：
##栈：
###什么是栈？又该怎么理解呢？
* ①栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。
* ②栈就是一个桶，后放进去的先拿出来，它下面本来有的东西要等它出来之后才能出来（先进后出）
* ③栈(Stack)是操作系统在建立某个进程时或者线程（在支持多线程的操作系统中是线程）为这个线程建立的存储区域，该区域具有FIFO的特性，在编译的时候可以指定需要的Stack的大小。

###堆栈：什么是堆栈？又该怎么理解呢？
* 注意：其实堆栈本身就是栈，只是换了个抽象的名字。
* 堆栈的特性： 最后一个放入堆栈中的物体总是被最先拿出来， 这个特性通常称为后进先出(LIFO)队列。 堆栈中定义了一些操作。 
* 两个最重要的是PUSH和POP。 PUSH操作在堆栈的顶部加入一 个元素。POP操作相反， 在堆栈顶部移去一个元素， 并将堆栈的大小减一。

###堆、栈区别总结：
####1.堆栈空间分配
 * ①栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
 * ②堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。
 
####2.堆栈缓存方式
* ①栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。
* ②堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

####3.堆栈数据结构区别
* ①堆（数据结构）：堆可以被看成是一棵树，如：堆排序。
* ②栈（数据结构）：一种先进后出的数据结构。

##队列：什么是队列？又该怎么理解呢？
* ①队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。
* ②队列中没有元素时，称为空队列。
* ③建立顺序队列结构必须为其静态分配或动态申请一片连续的存储空间，并设置两个指针进行管理。一个是队头指针front，它指向队头元素；另一个是队尾指针rear，它指向下一个入队元素的存储位置。
* ④队列采用的FIFO(first in first out)，新元素（等待进入队列的元素）总是被插入到链表的尾部，而读取的时候总是从链表的头部开始读取。每次读取一个元素，释放一个元素。所谓的动态创建，动态释放。因而也不存在溢出等问题。由于链表由结构体间接而成，遍历也方便。（先进先出）

###堆、栈、队列之间的区别是？
* ①堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。
* ②栈就是一个桶，后放进去的先拿出来，它下面本来有的东西要等它出来之后才能出来。（后进先出）
* ③队列只能在队头做删除操作,在队尾做插入操作.而栈只能在栈顶做插入和删除操作。（先进先出）

###完全二叉树：
叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树
###二叉排序树
二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

* （1）若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；
* （2）若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
* （3）左、右子树也分别为二叉排序树；


##什么是CGI
1. 定义：
CGI(Common Gateway Interface)是HTTP服务器与你的或其它机器
上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。

最早的Web服务器简单地响应浏览器发来的HTTP请求，并将存储在服务器上的HTML文件返回给浏览器，也就是静态html。事物总是不 断发展，网站也越来越复杂，所以出现动态技术。但是服务器并不能直接运行 php，asp这样的文件，自己不能做，外包给别人吧，但是要与第三做个约定，我给你什么，然后你给我什么，就是握把请求参数发送给你，然后我接收你的处 理结果给客户端。那这个约定就是 common gateway interface，简称cgi。这个协议可以用vb，c，php，python 来实现。cgi只是接口协议，

##声明试

先把图建立出来才会运行


##定义式

rnn 循环神经网络

lstm  长短时记忆神经网路


## Git代码回滚
1. 重置－－混合合并到 需要重置的历史节点
2. 重置－－软合并到当前节点 ，此时即可获取到从历史节点到当前节点的所有修改记录，此时可以修改文件，进行新的提交。