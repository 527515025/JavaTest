Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。

Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：

![image-20201118210458633](/Users/yangyibo/Library/Application Support/typora-user-images/image-20201118210458633.png)

# 1. 乐观锁 VS 悲观锁

悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。
乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升

## 1.1 乐观锁 
乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以**在数据进行提交更新的时候**，才会正式**对数据的冲突与否进行检测**。

乐观锁在Java中是通过**使用无锁编程**来实现，最常采用的是**CAS算法**，Java**原子类（JUC即java.util.concurrent包中的原子类）中的递增操作**就通过CAS自旋实现的。CAS全称 Compare And Swap（比较与交换）

小解：AtomicInteger的自增函数 incrementAndGet() 的源码时，发现自增函数底层调用的是 unsafe.getAndAddInt()

**CAS算法涉及到三个操作数：**

- 需要读写的内存值 V。
- 进行比较的值 A。
- 要写入的新值 B。

当且仅当 **V 的值等于 A** 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，**“更新”是一个不断重试的操作。**

**优点**：1.读不加锁，写加锁。提高吞吐量。

**缺点：**

* **循环时间长开销大**，CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。
* **只能保证一个共享变量的原子操作**。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。
  - Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。

### 1.1.1 ABA 问题

![image-20201118211210173](/Users/yangyibo/Library/Application Support/typora-user-images/image-20201118211210173.png)

举例说明：

1、现有一个单向链表实现的堆栈，栈顶为A，线程1获取到A.next为B，线程1希望通过CAS操作将栈顶替换为B

2、在线程1执行CAS操作之前，线程2来执行，将A、B出站，在依次入栈D、C、A，而对象B处于游离状态

3、此时线程1执行CAS操作，检测栈顶为A，CAS成功执行，栈顶为B，实际是B.next = null,此时堆栈只有一个B，C和D组成的链表不在堆栈中，C\D 被丢弃了

### ABA问题的解决方案

ABA问题的解决需要**使用版本号**，在变量前加上版本号，每次变量的变更操作版本号+1，那么A-B-A就变成1A-2B-3A。

## 1. 2 悲观锁

悲观锁认为**被它保护的数据是极其不安全**的，每时每刻都有可能变动，一个事务拿到悲观锁后（可以理解为一个用户），其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。

数据库中的**行锁，表锁，读锁，写锁**，以及 Java中，**synchronized关键字和Lock**的实现类都是悲观锁。

优点：悲观锁**利用数据库中的锁机制来实现数据变化的顺序**执行，这是最有效的办法

悲观锁存在问题：

1、多线程竞争，引起性能问题 （锁的释放和获取需要上下文切换和调度等）

2、一个线程获取锁会导致其他线程被挂起（阻塞）

# 2. 自旋锁 VS 适应性自旋锁

## 2.1 自旋锁

阻塞或唤醒一个Java线程需要**操作系统切换CPU状态**来完成，这种状态转换需要耗费处理器时间。**如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长**。

在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让那个**请求锁的线程不放弃CPU的执行时间**（避免放弃之后线程切换浪费cpu资源），看看持有锁的线程是否很快就会释放锁。

而**为了让当前线程“稍等一下”，我们需让当前线程进行自旋**，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。

自旋锁本身是有缺点的，**它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间**。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，**如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源**。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。

**自旋锁的实现原理同样也是CAS**，AtomicInteger中调用unsafe进行自增操作的源码中的**do-while循环就是一个自旋操作**，如果修改数值失败则通过循环来执行自旋，直至修改成功。

自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。

## 2.2 适应性自旋锁

**自适应意味着自旋的时间（次数）不再固定**，而是**由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定**。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。

在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock

# 3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁 

如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。

这种依赖于**操作系统Mutex Lock所实现的锁我们称之为“重量级锁”**，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。

这四种锁是指锁的状态，专门针对synchronized的。是对synchronized 的优化。

![image-20201118215410452](/Users/yangyibo/Library/Application Support/typora-user-images/image-20201118215410452.png)

上面几种锁都是**JVM自己内部实现，当我们执行synchronized同步块**的时候jvm会根据启用的锁和当前线程的争用情况，决定如何执行同步操作；

在所有的锁都启用的情况下线程进入临界区时会先去获取偏向锁，如果已经存在偏向锁了，则会尝试获取轻量级锁，启用自旋锁，如果自旋也没有获取到锁，则使用重量级锁，没有获取到锁的线程阻塞挂起，直到持有锁的线程执行完同步块唤醒他们；

synchronized的执行过程： 

1. 检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁 

2. 如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1 

3. 如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。 

4. 当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁 

5. 如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。 

6. 如果自旋成功则依然处于轻量级状态。 

7. 如果自旋失败，则升级为重量级锁。

## 3.1 死锁

死锁的四个条件

- 1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用
- 2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。
- 3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。
- 4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。

## 3.2 无锁

**无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。**

无锁的特点就是**修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试**。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。

## 3.3 偏向锁

偏向锁：仅有一个线程进入临界区

大多数情况下，锁不存在多线程竞争，而是总是由同一线程多次获得时，为了使线程获得锁的代价更低而引入了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。偏向锁是指**一段同步代码一直被一个线程**所访问，那么**该线程会自动获取锁**，降低获取锁的代价。当有第二个线程进入同步代码块时，则升级为轻量级锁

引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。

偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，**线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行**），它会**首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态**。

**偏向锁在JDK 6及以后的JVM里是默认启用的**。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，**关闭之后程序默认会进入轻量级锁状态。**

## 3.4 轻量级锁

轻量级锁：**多个**线程**交替**进入临界区（偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不进行阻塞，只是交替执行，提高性能）

当有另一个线程与该线程同时竞争时，锁会升级为重量级锁。为了防止继续自旋，**一旦升级，将无法降级**。

缺点：如果*锁竞争激烈*，那么轻量级将很快膨胀为重量级锁，那么维持轻量级锁的过程就成了浪费。

升级：

若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。

## 3.5 重量级锁

重量级锁：多个线程同时进入临界区（发生竞争）

其他线程试图获取锁时，都会被阻塞，只有持有锁的线程释放锁之后才会唤醒这些线程，进行竞争。

重量级锁是我们常说的传统意义上的锁。其利用操作系统底层的同步机制去实现Java中的线程同步。（linux上使用mutex互斥锁，最底层实现依赖于futex）

## 3.6 总结

此处只是简单的介绍这四种锁，如果想要具体了解四种锁的实现，及加解锁过程可移步 AAA。

综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。

# 4. 公平锁 VS 非公平锁

java 的 ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。

Sync有公平锁FairSync和非公平锁NonfairSync两个子类。**ReentrantLock默认使用非公平锁NonfairSync**，也可以通过构造器来显示的指定使用公平锁。

## 4.1 公平锁

**当有线程请求获取锁时，公平锁则会验证阻塞队列是否有阻塞线程，有队列会加到阻塞队列中**。队列中的第一个线程才能获得锁。

优点：是等待锁的线程不会饿死。

缺点：是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。

## 4.2 非公平锁

非公平获取锁（默认，提高吞吐量)

当有线程竞争锁时，当前线程会**首先尝试获得锁**而不是在队列中进行排队等候，获取不到才会到等待队列的队尾等待。这对于那些已经在队列中排队的线程来说显得不公平，这是非公平锁。

优点：

可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。

释疑：

假如一个线程刚好释放锁后唤醒后一个等待的线程A准备去获取锁时，一个新线程B进来尝试获取就会直接成功。

**如果在待唤醒的线程A获取锁之前，这个新进来的线程B持有锁然后再释放锁就不会影响待唤醒线程A的获取锁。这样就提高了程序的吞吐量**，

即使线程A在获取锁时因为B还没释放而获取失败，也不过是重新获取，不论怎样都提高了线程B的响应，提高了整体索取锁的吞吐量

# 5. 可重入锁 VS 非可重入锁

可重入锁又名**递归锁**，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（**前提锁对象得是同一个对象或者class**），不会因为之前已经获取过还没释放而阻塞。

**Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。**

## 5.2 非可重入锁

非可重入锁与可重入锁相反，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法获取锁会失败阻塞，导致当前线程出现死锁。然后整个等待队列中的所有线程都无法被唤醒。

Java中 的NonReentrantLock是非可重入锁。

# 6. 独享锁 VS 共享锁

## 6.1 独享锁（互斥锁）

独享锁 是指该锁一次只能被一个线程所持有。

如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。

JDK中的synchronized和JUC中Lock的实现类就是独享锁（互斥锁）。
## 6.2 共享锁

共享锁是指**该锁可被多个线程所持有**。如果线程T对数据A加上共享锁后，则其他线程**只能对A再加共享锁，不能加排它锁**。获得共享锁的线程**只能读数据，不能修改数据**。

独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。在ReentrantReadWriteLock里面，**读锁和写锁的锁主体都是Sync**，但读锁和写锁的加锁方式不一样。**读锁是共享锁，写锁是独享锁**。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。



此处只是简单的介绍，如果想要具体了解 java 两种锁 实现及加解锁过程可移步 AAA。

参考：https://tech.meituan.com/2018/11/15/java-lock.html

