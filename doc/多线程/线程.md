# 什么是进程
一文讲透 “进程、线程、协程”
https://mp.weixin.qq.com/s/BzJw4S3O7lZikTyhGa4P9A

进程-操作系统提供的**抽象概念**，是**系统进行资源分配和调度的基本单位**，是**操作系统结构的基础**。**程序是指令、数据及其组织形式的描述**，**进程是程序的实体**。**程序本身是没有生命周期的，它只是存在磁盘上的一些指令**,程序**一旦运行就是进程**

当程序需要运行时，操作系统将代码和所有**静态数据记载到内存和进程的地址空间**（**每个进程都拥有唯一的地址空间**，见下图所示）中，通过创建和初始化栈（局部变量，函数参数和返回地址)、分配堆内存以及与IO相关的任务，当前期准备工作完成，启动程序，OS将CPU的控制权转移到新创建的进程，进程开始运行。

![image-20200923231823035](/Users/yangyibo/Library/Application Support/typora-user-images/image-20200923231823035.png)

操作系统对**进程的控制和管理**通过PCB(Processing Control Block)，**PCB通常是系统内存占用区中的一个连续存区**，它**存放着操作系统用于描述进程情况及控制进程运行所需的全部信息**(进程标识号,进程状态,进程优先级,文件系统指针以及各个寄存器的内容等)，**进程的PCB是系统感知进程的唯一实体**。

一个进程至少具有5种基本状态：**初始态、执行状态、等待（阻塞）状态、就绪状态、终止状态**

- 初始状态：进程刚被创建，由于其他进程正占有CPU所以得不到执行，只能处于初始状态。
- 执行状态：任意时刻处于执行状态的进程只能有一个。
- 就绪状态：只有处于就绪状态的经过调度才能到执行状态
- 等待状态：**进程等待某件事件完成**
- 停止状态：进程结束

## 进程间的切换

无论是在多核还是单核系统中，一个CPU看上去都像是在并发的执行多个进程，这是通过**处理器在进程间切换**来实现的。

操作系统对把**CPU控制权在不同进程之间交换执行的机制成为上下文切换**（context switch），即保存当前进程的上下文，恢复新进程的上下文，然后将CPU控制权转移到新进程，新进程就会从上次停止的地方开始。因此，进程是轮流使用CPU的，CPU被若干进程共享，使用某种调度算法来决定何时停止一个进程，并转而为另一个进程提供服务。

* 单核CPU双进程的情况 ：进程直接**特定的机制和遇到I/O中断的情况下，进行上下文切换**，轮流使用CPU资源

  ![image-20200923232108624](/Users/yangyibo/Library/Application Support/typora-user-images/image-20200923232108624.png)

* 双核CPU双进程的情况 ：**每一个进程独占一个CPU核心资源**，在处理I/O请求的时候，CPU处于阻塞状态

  ![image-20200923232121040](/Users/yangyibo/Library/Application Support/typora-user-images/image-20200923232121040.png)

## 进程间数据共享

系统中的**进程与其他进程共享CPU和主存资源**，为了更好的管理主存，现在系统提供了一种对**主存的抽象概念**，即为**虚拟存储器（VM）**。它是一个抽象的概念，**它为每一个进程提供了一个假象，即每个进程都在独占地使用主存**。

虚拟存储器主要提供了三个能力：　

- 将主存看成是一个存储在磁盘上的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，更高效地使用主存
- 为每个进程提供了一致的地址空间，从而简化了存储器管理
- **保护了每个进程的地址空间不被其他进程破坏**

> 由于**进程拥有自己独占的虚拟地址空间**，CPU通过地址翻译将虚拟地址转换成真实的物理地址，**每个进程只能访问自己的地址空间**。因此，**在没有其他机制（进程间通信）的辅助下，进程之间是无法共享数据的**

## 进程间通讯

1. 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
2. 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
3. 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
4. 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
5. 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
6. 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
7. 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生

# 什么是线程

线程-也是**操作系统提供的抽象概念**，是程序执行中一个单一的顺序控制流程，是**程序执行流的最小单元**，是处**理器调度和分派的基本单位**。一个**进程可以有一个或多个线程**，同一进程中的多个线程将**共享该进程中的全部系统资源**，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有**各自的调用栈和线程本地存储**（如下图所示）。

![image-20200924000037805](/Users/yangyibo/Library/Application Support/typora-user-images/image-20200924000037805.png)

系统利用PCB来完成对进程的控制和管理。同样，系统为线程分配一个线程控制块**TCB（Thread Control Block）**,将所有用于控制和管理线程的信息记录在线程的控制块中，TCB中通常包括：

- **线程标志符**
- **一组寄存器**
- 线程运行状态
- 优先级
- 线程专有存储区
- 信号屏蔽

和进程一样，线程同样有五种状态：初始态、执行状态、等待（阻塞）状态、就绪状态和终止状态,**线程之间的切换和进程一样也需要上下文切换**，这里不再赘述。

## 什么是协程

协程（Coroutine，又称微线程）是一种**比线程更加轻量级的存在**，**协程不是被操作系统内核所管理**，而**完全是由程序所控制**。协程与线程以及进程的关系见下图所示。

- **协程可以比作子程序**，但执行过程中，**子程序内部可中断，然后转而执行别的子程序**，在适当的时候再**返回来接着执行。协程之间的切换不需要涉及任何系统调用或任何阻塞调用**
- **协程只在一个线程中执行，是子程序之间的切换**，发生在用户态上。而且，**线程的阻塞状态是由操作系统内核来完成，发生在内核态上，因此协程相比线程节省线程创建和切换的开销**
- 协程中**不存在同时写变量冲突，因此，也就不需要用来守卫关键区块的同步性原语，比如互斥锁**、信号量等，并且**不需要来自操作系统的支持**。

**协程适用于IO阻塞且需要大量并发的场景，当发生IO阻塞，由协程的调度器进行调度**，通过将数据流**yield掉，**并且记录当前栈上的数据，**阻塞完后立刻再通过线程恢复栈**，并把阻塞的结果放到这个线程上去运行。

![image-20200924001540885](/Users/yangyibo/Library/Application Support/typora-user-images/image-20200924001540885.png)

## 进程 VS 线程

- **进程是资源的分配和调度的独立单元**。进程**拥有完整的虚拟地址空间，当发生进程切换时，不同的进程拥有不同的虚拟地址空间**。而**同一进程的多个线程是可以共享同一地址空间**
- **线程是CPU调度的基本单元，一个进程包含若干线程**。
- **线程比进程小，基本上不拥有系统资源**。**线程的创建和销毁所需要的时间比进程小很多**
- 由于**线程之间能够共享地址空间，因此，需要考虑同步和互斥操作**
- **一个线程的意外终止会影响整个进程的正常运行，但是一个进程的意外终止不会影响其他的进程的运行。因此，多进程程序安全性更高。**

> 总之，**多进程程序安全性高，进程切换开销大**，效率低；多线程程序维护成本高，线程切换开销小，效率高。（**python的多线程是伪多线程，下文中将详细介绍**）

## 为什么要使用线程

 使用线程可以提高cpu 利用率。线程的创建和销毁所需要的时间比进程小，比进程轻量。线程间的通信代价小。

## java 线程生命周期

*  新建（new Thread）
   当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。
   例如：Thread  t1=new Thread();

*  就绪（runnable）
   线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();

*  运行（running）
   线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。

*  死亡（dead）
   当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。
   *  自然终止：正常运行run()方法后终止
   *  异常终止：调用stop()方法让一个线程终止运行
*  堵塞（blocked）
   由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。
   * 正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。
   * 正在等待：调用wait()方法。（调用motify()方法回到就绪状态）
   * 被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）

## 2.常用方法

* void run()   创建该类的子类时必须实现的方法
* void start() 开启线程的方法
* static void sleep(long t) 释放CPU的执行权，不释放锁
* static void sleep(long millis,int nanos)
* final void wait()释放CPU的执行权，释放锁
* final void notify()
* static void yied()可以对当前线程进行临时暂停（让线程将资源释放出来）

## 3 wait() 与notify()/notifyAll()/sleep

这三个方法都是Object的方法，并不是线程的方法！

* wait():释放占有的对象锁，线程进入等待池，释放cpu,而其他正在等待的线程即可抢占此锁，获得锁的线程即可运行程序。而sleep()不同的是，线程调用此方法后，会休眠一段时间，休眠期间，会暂时释放cpu，但并不释放对象锁。也就是说，在休眠期间，其他线程依然无法进入此代码内部。休眠结束，线程重新获得cpu,执行代码。wait()和sleep()最大的不同在于wait()会释放对象锁，而sleep()不会！ 
* notify(): 该方法会唤醒因为调用对象的wait()而等待的线程，其实就是对对象锁的唤醒，从而使得wait()的线程可以有机会获取对象锁。调用notify()后，并不会立即释放锁，而是继续执行当前代码，直到synchronized中的代码全部执行完毕，才会释放对象锁。JVM则会在等待的线程中调度一个线程去获得对象锁，执行代码。需要注意的是，wait()和notify()必须在synchronized代码块中调用。
* notifyAll()则是唤醒所有等待的线程。
* sleep方法在等待时不会释放任何锁或监视器

## 为什么使用多线程？

1.避免阻塞（异步调用） 。单个线程中的程序，是顺序执行的。如果前面的操作发生了阻塞，那么就会影响到后面的操作。这时候可以采用多线程，我感觉就等于是异步调用。这样的例子有很多： 

ajax调用，就是浏览器会启一个新的线程，不阻塞当前页面的正常操作；

2.避免CPU空转 ：以http server为例，如果只用单线程响应HTTP请求，即处理完一条请求，再处理下一条请求的话，CPU会存在大量的闲置时间 。因为处理一条请求，经常涉及到RPC、数据库访问、磁盘IO等操作，这些操作的速度比CPU慢很多，而在等待这些响应的时候，CPU却不能去处理新的请求，因此http server的性能就很差 

所以很多web容器，都采用对每个请求创建新线程来响应的方式实现，这样在等待请求A的IO操作的等待时间里，就可以去继续处理请求B，对并发的响应性就好了很多 

当然，这种设计方式并不是绝对的，现在像node.js、Nginx等新一代http server，采用了事件驱动的实现方式，用单线程来响应多个请求也是没问题的。甚至实现了更高的性能，因为多线程是一把双刃剑，在提升了响应性的同时，创建销毁线程都是需要开销的，另外CPU在线程之间切换，也会带来额外的开销。避免了这些额外开销，可能是node.js等http server性能优秀的原因之一吧 

3.提升性能，比如做饭，多个人配菜、切菜，提高做菜效率。

在满足条件的前提下，多线程确实能提升性能 

基本上，需要满足3个条件： 

* 第1，任务具有并发性，也就是可以拆分成多个子任务。并不是什么任务都能拆分的，条件还比较苛刻。 子任务之间不能有先后顺序的依赖，必须是允许并行的 

* 第2，只有在CPU是性能瓶颈的情况下，多线程才能实现提升性能的目的。比如一段程序，**瓶颈在于IO操作**，那么把这个程序拆分到2个线程中执行，也是无法提升性能的 

* 第3，有点像废话，就是需要有多核CPU才行。否则的话，虽然拆分成了多个可并行的子任务，但是没有足够的CPU，还是只有一个CPU在多个线程中切换来切换去，不但达不到提升性能的效果，反而由于增加了额外的开销，而降低了性能。例如： 把菜放到了2个锅里，但是只有1个炉子一样 

### 总结应用场景和方案

- CPU密集型：多进程
- IO密集型：多线程（协程维护成本较高,而且在读写文件方面效率没有显著提升）
- CPU密集和IO密集：多进程+协程

## 产生线程不安全的原因

在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。

## 竞态条件 & 临界区

当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作**临界区**。上例中add()方法就是一个临界区,它会产生**竞态条件**。在临界区中使用适当的同步就可以避免竞态条件。

```
public class Counter {
    protected long count = 0;

    public void add(long value){
        this.count = this.count + value;  
    }
}

```

两个线程交替执行结果如下

```
this.count = 0;
   A:   读取 this.count 到一个寄存器 (0)
   B:   读取 this.count 到一个寄存器 (0)
   B:   将寄存器的值加2
   B:   回写寄存器值(2)到内存. this.count 现在等于 2
   A:   将寄存器的值加3
   A:   回写寄存器值(3)到内存. this.count 现在等于 3
```

## 共享资源

允许被多个线程同时执行的代码称作线程安全的代码叫做共享资源。**线程安全的代码不包含竞态条件**。当多个线程同时更新共享资源时会引发竞态条件。

##局部变量

局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享。所以，基础类型的局部变量是线程安全的。

```
public void someMethod(){
  long threadSafeInt = 0;//局部变量
  threadSafeInt++;
}
```

##局部的对象引用

上面提到的局部变量是一个基本类型，如果局部变量是一个**对象类型**呢？对象的局部引用和基础类型的局部变量不太一样。尽管引用本身没有被共享，但引用所指的对象并没有存储在线程的栈内，**所有的对象都存在共享堆**中，所以对于局部对象的引用，有可能是线程安全的，也有可能是线程不安全的。

如果在某个方法中创建的对象不会被其他方法或全局变量获得，或者说方法中创建的对象没有逃出此方法的范围，那么它就是**线程安全**的。实际上，哪怕将这个对象作为参数传给其它方法，只要**别的线程获取不到这个对象**，那它仍是线程安全的。

```
public void someMethod(){
  LocalObject localObject = new LocalObject();
  localObject.callMethod();
  method2(localObject);
}

public void method2(LocalObject localObject){
  localObject.setValue("value");
}
```

上面样例中 LocalObject 对象没有被方法返回，也没有被传递给someMethod()方法外的对象，始终在someMethod()方法内部。**每个执行someMethod()的线程都会创建自己的LocalObject对象**，并赋值给localObject引用。因此，这里的LocalObject是线程安全的。事实上，整个someMethod()都是线程安全的。即使将LocalObject作为参数传给同一个类的其它方法或其它类的方法时，它仍然是**线程安全**的。当然，如果LocalObject通过某些方法被传给了别的线程，那它就不再是线程安全的了。
	

```
如果一个资源的创建，使用，销毁都在同一个线程内完成，且永
远不会脱离该线程的控制，则该资源的使用就是线程安全的。
```



引入重点 下一篇 锁

引入重点 下一篇 实现线程安全的方案

引入重点 下一篇 关键字

引入重点 下一篇 实践线程池